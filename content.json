{"meta":{"title":"小小苏的个人博客","subtitle":null,"description":null,"author":"Jessa Su","url":"https://sucj0301.github.io","root":"/"},"pages":[],"posts":[{"title":"改变选中标签样式'","slug":"改变选中标签样式","date":"2020-03-31T08:18:25.000Z","updated":"2020-03-31T08:18:25.639Z","comments":true,"path":"2020/03/31/改变选中标签样式/","link":"","permalink":"https://sucj0301.github.io/2020/03/31/改变选中标签样式/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"监听屏幕滑动事件'","slug":"监听屏幕滑动事件","date":"2020-03-29T10:38:01.000Z","updated":"2020-03-29T14:03:11.211Z","comments":true,"path":"2020/03/29/监听屏幕滑动事件/","link":"","permalink":"https://sucj0301.github.io/2020/03/29/监听屏幕滑动事件/","excerpt":"","text":"需求：打开菜单栏或者下拉列表时触摸/滚动屏幕关闭菜单或下拉列表 第一步 123mounted() &#123; window.addEventListener(&apos;touchmove&apos;,this.myTouchMove,false) &#125;, 第二步 1234567methods: &#123; // 屏幕滑动事件 myTouchMove() &#123; console.log(&apos;滑动了&apos;) // 要实现的功能 &#125;,&#125; 第三步 123// 移除事件！window.removeEventListener(&apos;touchmove&apos;,this.myTouchMove,true) addEventListene第三个参数为true则是在捕获过程执行，false为在冒泡过程执行。关于捕获和冒泡参考 点击这里","categories":[],"tags":[]},{"title":"vue实时监听滚动条位置","slug":"vue实时监听滚动条位置","date":"2020-03-27T10:29:07.000Z","updated":"2020-03-27T10:30:30.027Z","comments":true,"path":"2020/03/27/vue实时监听滚动条位置/","link":"","permalink":"https://sucj0301.github.io/2020/03/27/vue实时监听滚动条位置/","excerpt":"","text":"123456789101112 mounted() &#123; // 监听window中滚动条的位置 window.addEventListener(&apos;scroll&apos;, function()&#123; let scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop; console.log(scrollTop); &#125;); // 监听指定某个元表滚动条的位置 document.querySelector(&apos;#listBox&apos;).addEventListener(&apos;scroll&apos;, function()&#123; let scrollTop = this.pageYOffset || this.scrollTop; console.log(scrollTop);&#125;","categories":[],"tags":[]},{"title":"'vue-路由切换但是滚动条位置没变'","slug":"vue-路由切换但是滚动条位置没变","date":"2020-03-27T08:57:48.000Z","updated":"2020-03-27T08:57:48.774Z","comments":true,"path":"2020/03/27/vue-路由切换但是滚动条位置没变/","link":"","permalink":"https://sucj0301.github.io/2020/03/27/vue-路由切换但是滚动条位置没变/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"'vue-pc端微信和支付宝支付'","slug":"vue-pc端微信和支付宝支付","date":"2020-03-27T08:55:42.000Z","updated":"2020-03-27T08:55:42.257Z","comments":true,"path":"2020/03/27/vue-pc端微信和支付宝支付/","link":"","permalink":"https://sucj0301.github.io/2020/03/27/vue-pc端微信和支付宝支付/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"'vue-移动端微信和支付宝支付'","slug":"vue-移动端微信和支付宝支付","date":"2020-03-27T08:55:27.000Z","updated":"2020-03-27T08:55:27.757Z","comments":true,"path":"2020/03/27/vue-移动端微信和支付宝支付/","link":"","permalink":"https://sucj0301.github.io/2020/03/27/vue-移动端微信和支付宝支付/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"'vue——NodeJs项目中对process.env的使用'","slug":"vue——NodeJs项目中对process-env的使用","date":"2020-03-16T02:31:35.000Z","updated":"2020-03-16T02:31:55.100Z","comments":true,"path":"2020/03/16/vue——NodeJs项目中对process-env的使用/","link":"","permalink":"https://sucj0301.github.io/2020/03/16/vue——NodeJs项目中对process-env的使用/","excerpt":"","text":"(https://blog.csdn.net/qq_40963664/article/details/88016586)[https://blog.csdn.net/qq_40963664/article/details/88016586]","categories":[],"tags":[]},{"title":"vue-cli3-vue.config.js文件配置","slug":"vue-cli3-vue-config-js文件配置","date":"2020-03-16T02:24:30.000Z","updated":"2020-03-16T02:25:10.603Z","comments":true,"path":"2020/03/16/vue-cli3-vue-config-js文件配置/","link":"","permalink":"https://sucj0301.github.io/2020/03/16/vue-cli3-vue-config-js文件配置/","excerpt":"","text":"(https://segmentfault.com/a/1190000016101954)[https://segmentfault.com/a/1190000016101954] (https://www.cnblogs.com/xzychoose/p/11505113.html)[https://www.cnblogs.com/xzychoose/p/11505113.html]","categories":[],"tags":[]},{"title":"public目录下utils.js工具配置文件'","slug":"public目录下utils-js工具配置文件","date":"2020-03-16T01:36:54.000Z","updated":"2020-03-16T01:48:09.569Z","comments":true,"path":"2020/03/16/public目录下utils-js工具配置文件/","link":"","permalink":"https://sucj0301.github.io/2020/03/16/public目录下utils-js工具配置文件/","excerpt":"","text":"需求： (参考)[https://blog.csdn.net/ywl570717586/article/details/81002579?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task] (extract-text-webpack-plugin)[https://www.jianshu.com/p/e244c92f8292]","categories":[],"tags":[]},{"title":"vue-cli3引入字体文件","slug":"vue-cli3引入字体文件","date":"2020-03-15T05:34:57.000Z","updated":"2020-03-15T06:18:26.279Z","comments":true,"path":"2020/03/15/vue-cli3引入字体文件/","link":"","permalink":"https://sucj0301.github.io/2020/03/15/vue-cli3引入字体文件/","excerpt":"","text":"需求： 引入自定义字体文件XX.ttf 找到想要的字体下载.ttf文件 把.ttf文件放到assets文件夹的font文件夹下并创建font.css文件 在font.css里写 123456@font-face &#123; font-family: &apos;YRDZXT&apos;; // 自定义字体名称 src: url(&quot;YRDZXT-Extralight.ttf&quot;); // 引入.ttf文件 font-weight: normal; font-style: normal;&#125; vue.config.js里（配置解析字体文件） 12345678910111213141516171819module.exports = &#123; // 其他配置 configureWebpack: &#123; module: &#123; rules: [ &#123; test: /\\.(woff2?|eot|ttf|otf)(\\?.*)$/, loader: &apos;url-loader&apos;, options: &#123; limit: 10000, name: utils.assetsPath(&apos;fonts/[name].[hash:7].[ext]&apos;) &#125; &#125; ] &#125; &#125;&#125; 在App.vue里 123&lt;style lang=&quot;less&quot;&gt; @import &quot;common/font.css&quot;;&lt;/style&gt; 在需要引入的页面组件中直接使用 123.class &#123; font-family: &apos;YRDZXT&apos;;&#125;","categories":[],"tags":[]},{"title":"什么？下划线的长度不满意？还想要一个竖线？","slug":"什么？下划线的长度不满意？还想要一个竖线？","date":"2020-03-13T08:18:52.000Z","updated":"2020-03-13T08:25:16.813Z","comments":true,"path":"2020/03/13/什么？下划线的长度不满意？还想要一个竖线？/","link":"","permalink":"https://sucj0301.github.io/2020/03/13/什么？下划线的长度不满意？还想要一个竖线？/","excerpt":"","text":"需求： 设置任意长宽的横线或竖线实例：验证码前面加一个竖线 1234567891011121314151617181920212223template==================== &lt;div class=&quot;code&quot; style=&quot;margin-bottom: 1rem;&quot;&gt; &lt;Input class=&quot;num&quot; v-model=&quot;code&quot; placeholder=&quot;验证码&quot; style=&quot;margin-bottom: unset;&quot;/&gt; &lt;Button v-if=&quot;!clickGetCode&quot; @click=&quot;handleGetVerification&quot;&gt;获取验证码&lt;/Button&gt; &lt;Button v-else disabled&gt;&#123;&#123;getCodeLoading&#125;&#125;&lt;/Button&gt; &lt;/div&gt; style====================== .num &#123; border-bottom: unset !important; &amp;:after &#123; content: &apos;&apos;; position: absolute; width: 0.15rem; height: 2rem; background: #c0c4cb; bottom: 0.6rem; &#125; &#125;","categories":[],"tags":[]},{"title":"vue-判断用户是否处于登录状态","slug":"vue-判断用户是否处于登录状态","date":"2020-03-12T03:52:47.000Z","updated":"2020-03-12T03:55:00.155Z","comments":true,"path":"2020/03/12/vue-判断用户是否处于登录状态/","link":"","permalink":"https://sucj0301.github.io/2020/03/12/vue-判断用户是否处于登录状态/","excerpt":"","text":"需求：在需要登录的页面判断用户是否已登录，登录则…没登录则… https://blog.csdn.net/blackhehaha/article/details/93631138 https://blog.csdn.net/weixin_41753291/article/details/80619523","categories":[],"tags":[]},{"title":"对请求链接的urlencode处理","slug":"对请求链接的urlencode处理","date":"2020-03-10T13:10:26.000Z","updated":"2020-03-11T09:20:56.735Z","comments":true,"path":"2020/03/10/对请求链接的urlencode处理/","link":"","permalink":"https://sucj0301.github.io/2020/03/10/对请求链接的urlencode处理/","excerpt":"","text":"http://ai.baidu.com/forum/topic/show/954144 encodeURIComponent(‘url’)","categories":[],"tags":[]},{"title":"'链接的自动跳转'","slug":"链接的自动跳转","date":"2020-03-10T11:49:27.000Z","updated":"2020-03-10T12:02:50.287Z","comments":true,"path":"2020/03/10/链接的自动跳转/","link":"","permalink":"https://sucj0301.github.io/2020/03/10/链接的自动跳转/","excerpt":"","text":"https://www.cnblogs.com/THONLY/p/7246127.html https://blog.csdn.net/qq_42112846/article/details/90416285","categories":[],"tags":[]},{"title":"'vue实现搜索功能'","slug":"vue实现搜索功能","date":"2020-03-09T10:10:54.000Z","updated":"2020-03-09T10:13:56.121Z","comments":true,"path":"2020/03/09/vue实现搜索功能/","link":"","permalink":"https://sucj0301.github.io/2020/03/09/vue实现搜索功能/","excerpt":"","text":"123456789101112// 获取服务器信息fetchData(config = &#123;&#125;) &#123; this.listLoading = true; getList(Object.assign(&#123;page:this.page&#125;, config)).then(res =&gt; &#123; this.total = get(res,&apos;data.data.total&apos;) this.list = get(res, &apos;data.data.logs&apos;) this.listLoading = false; &#125;) .catch(() =&gt; &#123; this.listLoading = false; &#125;)&#125;, 123456789// 模糊搜索handleFuzzySearch() &#123; this.page = 1; this.fetchData(&#123; teacher_id:this.teacher_id, class_id: this.class_id, date: this.date &#125;)&#125;,","categories":[],"tags":[]},{"title":"vue对象类型赋值问题","slug":"vue对象类型赋值问题","date":"2020-03-09T05:19:59.000Z","updated":"2020-03-09T05:47:30.265Z","comments":true,"path":"2020/03/09/vue对象类型赋值问题/","link":"","permalink":"https://sucj0301.github.io/2020/03/09/vue对象类型赋值问题/","excerpt":"","text":"问题： https://www.jianshu.com/p/dac2b5ade1fd this.$set的使用","categories":[],"tags":[]},{"title":"如何在手机上预览vue项目","slug":"如何在手机上预览vue项目","date":"2020-03-05T16:02:48.000Z","updated":"2020-03-05T16:25:54.535Z","comments":true,"path":"2020/03/06/如何在手机上预览vue项目/","link":"","permalink":"https://sucj0301.github.io/2020/03/06/如何在手机上预览vue项目/","excerpt":"","text":"需求：写vue移动端项目时，需要在手机上预览 参考https://blog.csdn.net/qappleh/article/details/80987816","categories":[],"tags":[]},{"title":"vue-监听滚动条事件","slug":"vue-监听滚动条事件","date":"2020-03-04T05:22:00.000Z","updated":"2020-03-04T13:35:17.667Z","comments":true,"path":"2020/03/04/vue-监听滚动条事件/","link":"","permalink":"https://sucj0301.github.io/2020/03/04/vue-监听滚动条事件/","excerpt":"","text":"vue-实时监听滚动条事件 业务需求：点击课程列表中某一课程查看详情，返回的时候应该显示的是课程列表最后的状态，也就是要记录在切换页面前滚动条的最后位置。 页面组件classCenter里： 123456789&lt;div class=&quot;classList&quot; ref=&quot;scroll&quot;&gt;&lt;ul v-for=&quot;item in classList&quot; @click=&quot;handleToDetails&quot;&gt; &lt;li class=&quot;name&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/li&gt; &lt;li class=&quot;time&quot;&gt;时间:&#123;&#123;item.time&#125;&#125;&lt;/li&gt; &lt;li class=&quot;period&quot;&gt;课时:&#123;&#123;item.period&#125;&#125;&lt;/li&gt; &lt;li class=&quot;price&quot;&gt;￥&#123;&#123;item.price&#125;&#125;元&lt;/li&gt; &lt;Icon type=&quot;ios-arrow-forward&quot; size=&quot;20&quot;/&gt;&lt;/ul&gt;&lt;/div&gt; 我把滚动条高度放到vuex状态机里： 123state: &#123; class_list_top: 0&#125;, App.vue 把要实现需求的页面缓存下来 keep-alive使用方法 123&lt;keep-alive :include=&quot;[&apos;Home&apos;,&apos;classCenter&apos;]&quot;&gt; &lt;router-view /&gt;&lt;/keep-alive&gt; script里： 12345678910111213141516171819 activated () &#123; &lt;!-- 绑定scroll事件 --&gt; this.$refs.scroll.addEventListener(&quot;scroll&quot;,this.handleGetScrollTop); &lt;!-- 让dom元素的滚动条高度为记录到vuex的该元素最后的滚动条高度 --&gt; this.$refs.scroll.scrollTop = this.$store.state.class_list_top; &#125;, deactivated () &#123; &lt;!-- 移除scroll事件 --&gt; this.$refs.scroll.removeEventListener(&quot;scroll&quot;,this.handleGetScrollTop); &#125;, methods: &#123; &lt;!-- 获取classList滚动条高度 --&gt; handleGetScrollTop(e) &#123; this.$store.state.class_list_top = e.target.scrollTop; &#125;,&#125; 注意: ① activated、deactivated是必须配合keep-alive使用的② removeEventListener移除的事件必须和addEventListener一致（参数也要一致）；且通过addEventListener()添加的匿名函数无法移除。 activated、deactivated使用参考此文档 本文参考：https://segmentfault.com/a/1190000012857661","categories":[],"tags":[]},{"title":"vue监听路由变化","slug":"vue监听路由变化","date":"2020-03-02T04:54:49.000Z","updated":"2020-03-02T04:55:46.607Z","comments":true,"path":"2020/03/02/vue监听路由变化/","link":"","permalink":"https://sucj0301.github.io/2020/03/02/vue监听路由变化/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"'@media移动端适配'","slug":"media移动端适配","date":"2020-02-29T07:16:36.000Z","updated":"2020-02-29T08:09:13.523Z","comments":true,"path":"2020/02/29/media移动端适配/","link":"","permalink":"https://sucj0301.github.io/2020/02/29/media移动端适配/","excerpt":"","text":"常见移动设备的屏幕适配方案 比较耿直的写法 -。- 实例 12345678910111213141516171819202122232425262728293031 /* iphoneX适配*/ @media screen and (max-width: 375px) and (max-height: 812px) &#123; .类名 &#123; 属性名: 属性值; &#125; &#125; /* iphone6/7/8Plus适配*/ @media screen and (max-width: 414px) and (max-height: 736px) &#123; &#125; /* iphone6/7/8适配*/ @media screen and (max-width: 375px) and (max-height: 667px) &#123; &#125; /* Galaxy S5适配*/ @media screen and (max-width: 360px) and (max-height: 640px) &#123; &#125;/* iphone5/SE适配*/ @media screen and (max-width: 320px) and (max-height: 568px) &#123; &#125;/* iphone4适配*/ @media screen and (max-width: 320px) and (max-height: 480px) &#123; &#125; 注意：小的设备要写在大的下面，不然样式会被覆盖！！","categories":[],"tags":[]},{"title":"'vue项目-表单验证踩坑'","slug":"vue项目-表单验证踩坑","date":"2020-02-28T08:22:07.000Z","updated":"2020-02-28T08:22:07.110Z","comments":true,"path":"2020/02/28/vue项目-表单验证踩坑/","link":"","permalink":"https://sucj0301.github.io/2020/02/28/vue项目-表单验证踩坑/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"'vue项目-解决登录注册页面浏览器自动匹配历史记录账号密码问题'","slug":"vue项目-解决登录注册页面浏览器自动匹配历史记录账号密码问题","date":"2020-02-28T02:13:01.000Z","updated":"2020-02-28T03:06:54.423Z","comments":true,"path":"2020/02/28/vue项目-解决登录注册页面浏览器自动匹配历史记录账号密码问题/","link":"","permalink":"https://sucj0301.github.io/2020/02/28/vue项目-解决登录注册页面浏览器自动匹配历史记录账号密码问题/","excerpt":"","text":"方法一： https://www.cnblogs.com/jun-qi/p/11002850.html 方法二：","categories":[],"tags":[]},{"title":"'vue项目特定页面不想引用app.vue的公用组件的方法'","slug":"vue项目特定页面不想引用app-vue的公用组件的方法","date":"2020-02-26T01:58:34.000Z","updated":"2020-02-26T02:00:52.347Z","comments":true,"path":"2020/02/26/vue项目特定页面不想引用app-vue的公用组件的方法/","link":"","permalink":"https://sucj0301.github.io/2020/02/26/vue项目特定页面不想引用app-vue的公用组件的方法/","excerpt":"","text":"vue 参考https://blog.csdn.net/weixin_42545184/article/details/89311666","categories":[],"tags":[]},{"title":"vue实现聊天室最新消息在最底部","slug":"vue实现聊天室最新消息在最底部","date":"2020-02-20T13:45:28.000Z","updated":"2020-02-20T14:08:36.740Z","comments":true,"path":"2020/02/20/vue实现聊天室最新消息在最底部/","link":"","permalink":"https://sucj0301.github.io/2020/02/20/vue实现聊天室最新消息在最底部/","excerpt":"","text":"在写vue项目聊天室时要求最新的消息显示在可见区的最底部： 两步搞定 页面代码 123456&lt;div style=&quot;overflow: auto;height: 100%;&quot; ref=&quot;selfMsg&quot;&gt; &lt;div class=&quot;self-wrap&quot; v-for=&quot;(item,index) in messageList&quot; :key=&quot;index&quot;&gt; &lt;span class=&quot;-header&quot; &gt;我&lt;/span&gt; &lt;div class=&quot;-msg&quot; &gt;&#123;&#123;item.message&#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 注意的点：①要绑定ref ②ref要绑定在父容器上！！（emmm这种坑应该只能害到我吧） 在updated()里面写 12345if (this.$refs.hasOwnProperty(&apos;selfMsg&apos;)) &#123; this.$refs.selfMsg.scrollTop = this.$refs.selfMsg.scrollHeight;&#125; 还可以这样：(其实跟上面大同小异，只是以下是稍稳定的写法？) 页面代码同上 data()里面： 12345data() &#123; return &#123; trueScrollHeight: null &#125; &#125;, updated()里面： 12345if (this.$refs.hasOwnProperty(&apos;selfMsg&apos;)) &#123; this.trueScrollHeight = this.$refs.selfMsg; &#125; methods里面： 1234567891011121314// 发送消息的方法 handleSendMessage()&#123; //实现发送消息的代码 // 我要表达的 setTimeout(() =&gt; &#123; this.$refs.selfMsg.scrollTop =this.trueScrollHeight.scrollHeight; &#125;, 0) &#125;, 据说还可以用scrollIntoView()方法，我还不知道怎么用 参考这里https://blog.tachmiao.com/?id=14","categories":[],"tags":[]},{"title":"vue-cli3全面配置","slug":"vue-cli3全面配置","date":"2020-02-20T12:36:50.000Z","updated":"2020-02-20T12:41:51.655Z","comments":true,"path":"2020/02/20/vue-cli3全面配置/","link":"","permalink":"https://sucj0301.github.io/2020/02/20/vue-cli3全面配置/","excerpt":"","text":"这篇文章必须收藏！太perfect了https://segmentfault.com/a/1190000017008697 vue-cli4","categories":[],"tags":[]},{"title":"用过的WEB-API接口","slug":"API接口","date":"2020-02-19T13:52:48.000Z","updated":"2020-02-20T04:12:18.134Z","comments":true,"path":"2020/02/19/API接口/","link":"","permalink":"https://sucj0301.github.io/2020/02/19/API接口/","excerpt":"","text":"1.Element.scrollIntoView()2.document.querySelector()3.oninput事件https://www.runoob.com/jsref/event-oninput.html","categories":[],"tags":[]},{"title":"'vue音频组件vue-aplayer的使用'","slug":"vue音频组件vue-aplayer的使用","date":"2020-02-15T08:01:30.000Z","updated":"2020-02-15T08:01:30.317Z","comments":true,"path":"2020/02/15/vue音频组件vue-aplayer的使用/","link":"","permalink":"https://sucj0301.github.io/2020/02/15/vue音频组件vue-aplayer的使用/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"'html5——audio音频播放器的使用'","slug":"html5——audio音频播放器的使用","date":"2020-02-09T08:22:59.000Z","updated":"2020-02-09T08:22:59.639Z","comments":true,"path":"2020/02/09/html5——audio音频播放器的使用/","link":"","permalink":"https://sucj0301.github.io/2020/02/09/html5——audio音频播放器的使用/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"'vue项目——页面跳转并携带参数'","slug":"vue项目——页面跳转并携带参数","date":"2020-02-08T06:10:45.000Z","updated":"2020-02-08T06:10:45.629Z","comments":true,"path":"2020/02/08/vue项目——页面跳转并携带参数/","link":"","permalink":"https://sucj0301.github.io/2020/02/08/vue项目——页面跳转并携带参数/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"'获取当前时间函数'","slug":"获取当前时间函数","date":"2020-02-08T04:19:32.000Z","updated":"2020-02-08T04:19:32.784Z","comments":true,"path":"2020/02/08/获取当前时间函数/","link":"","permalink":"https://sucj0301.github.io/2020/02/08/获取当前时间函数/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"'FormData()的使用'","slug":"FormData-的使用","date":"2020-02-07T13:41:57.000Z","updated":"2020-02-07T13:41:57.734Z","comments":true,"path":"2020/02/07/FormData-的使用/","link":"","permalink":"https://sucj0301.github.io/2020/02/07/FormData-的使用/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"'lodash——深克隆'","slug":"lodash——深克隆","date":"2020-02-07T02:40:53.000Z","updated":"2020-02-07T02:40:53.211Z","comments":true,"path":"2020/02/07/lodash——深克隆/","link":"","permalink":"https://sucj0301.github.io/2020/02/07/lodash——深克隆/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"'wow.js的使用'","slug":"wow-js的使用","date":"2020-01-21T14:29:58.000Z","updated":"2020-01-21T14:29:59.041Z","comments":true,"path":"2020/01/21/wow-js的使用/","link":"","permalink":"https://sucj0301.github.io/2020/01/21/wow-js的使用/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"'vue粒子特效插件——vue-particles的使用'","slug":"vue粒子特效插件——vue-particles的使用","date":"2020-01-21T03:18:59.000Z","updated":"2020-01-21T03:18:59.890Z","comments":true,"path":"2020/01/21/vue粒子特效插件——vue-particles的使用/","link":"","permalink":"https://sucj0301.github.io/2020/01/21/vue粒子特效插件——vue-particles的使用/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"'pointer-events(控制鼠标点击事件)的使用'","slug":"pointer-events-控制鼠标点击事件-的使用","date":"2020-01-21T03:17:07.000Z","updated":"2020-01-21T03:17:07.797Z","comments":true,"path":"2020/01/21/pointer-events-控制鼠标点击事件-的使用/","link":"","permalink":"https://sucj0301.github.io/2020/01/21/pointer-events-控制鼠标点击事件-的使用/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"自适应热点图片宽度定位'","slug":"自适应热点图片宽度定位","date":"2020-01-17T05:02:35.000Z","updated":"2020-01-17T05:02:35.749Z","comments":true,"path":"2020/01/17/自适应热点图片宽度定位/","link":"","permalink":"https://sucj0301.github.io/2020/01/17/自适应热点图片宽度定位/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"'HTML5——map函数的使用'","slug":"HTML5——map函数的使用","date":"2020-01-17T04:58:55.000Z","updated":"2020-01-17T04:58:55.091Z","comments":true,"path":"2020/01/17/HTML5——map函数的使用/","link":"","permalink":"https://sucj0301.github.io/2020/01/17/HTML5——map函数的使用/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"'this.$nextTick的使用'","slug":"this-nextTick的使用","date":"2020-01-17T04:56:48.000Z","updated":"2020-01-17T04:56:48.331Z","comments":true,"path":"2020/01/17/this-nextTick的使用/","link":"","permalink":"https://sucj0301.github.io/2020/01/17/this-nextTick的使用/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"'@media实现响应式布局'","slug":"media实现响应式布局","date":"2020-01-17T04:52:54.000Z","updated":"2020-02-29T08:03:26.725Z","comments":true,"path":"2020/01/17/media实现响应式布局/","link":"","permalink":"https://sucj0301.github.io/2020/01/17/media实现响应式布局/","excerpt":"","text":"方式一https://blog.csdn.net/qq_37968920/article/details/82424009","categories":[],"tags":[]},{"title":"'吸顶工具函数and滚动条监听'","slug":"吸顶工具函数and滚动条监听","date":"2020-01-17T04:51:45.000Z","updated":"2020-01-17T04:51:45.840Z","comments":true,"path":"2020/01/17/吸顶工具函数and滚动条监听/","link":"","permalink":"https://sucj0301.github.io/2020/01/17/吸顶工具函数and滚动条监听/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"'flex布局的使用'","slug":"flex布局的使用","date":"2020-01-17T04:50:05.000Z","updated":"2020-01-17T04:50:05.083Z","comments":true,"path":"2020/01/17/flex布局的使用/","link":"","permalink":"https://sucj0301.github.io/2020/01/17/flex布局的使用/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"'Vue开发——吸顶效果的实现'","slug":"Vue开发——吸顶效果的实现","date":"2020-01-15T03:08:25.000Z","updated":"2020-01-15T03:08:25.191Z","comments":true,"path":"2020/01/15/Vue开发——吸顶效果的实现/","link":"","permalink":"https://sucj0301.github.io/2020/01/15/Vue开发——吸顶效果的实现/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"'vue学习笔记——mixin(混入)'","slug":"vue学习笔记——mixin-混入","date":"2020-01-11T10:33:40.000Z","updated":"2020-03-04T06:29:22.417Z","comments":true,"path":"2020/01/11/vue学习笔记——mixin-混入/","link":"","permalink":"https://sucj0301.github.io/2020/01/11/vue学习笔记——mixin-混入/","excerpt":"","text":"https://segmentfault.com/a/1190000017716554","categories":[],"tags":[]},{"title":"'VUE--$emit的用法'","slug":"VUE-emit的用法","date":"2020-01-02T08:52:17.000Z","updated":"2020-01-02T08:52:17.639Z","comments":true,"path":"2020/01/02/VUE-emit的用法/","link":"","permalink":"https://sucj0301.github.io/2020/01/02/VUE-emit的用法/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"写vue项目时用过的方法和函数","slug":"写项目时发现的一些方法，很实用","date":"2020-01-02T04:00:40.000Z","updated":"2020-03-12T03:15:28.857Z","comments":true,"path":"2020/01/02/写项目时发现的一些方法，很实用/","link":"","permalink":"https://sucj0301.github.io/2020/01/02/写项目时发现的一些方法，很实用/","excerpt":"","text":"一、lodash里面的一些常用方法前提 安装lodash 1npm i lodash -S 引入lodash(建议按需引入) 123456789// 1.全局引入 -&gt;在main.js文件中：import _ from &apos;lodash&apos;Vue.prototype._ = _// 2.单个页面引入let _ = require(&apos;lodash&apos;) 或 import _ from &apos;lodash&apos;// 2.引入单个函数，比如要引入trim这个函数let _trim = require(&apos;lodash/trim&apos;) 或 import trim form &apos;lodash/trim&apos; 常用方法 _.get(object, path, [defaultValue]) 根据 object对象的path路径获取值。 如果解析 value 是 undefined 会以 defaultValue 取代。等同于我们取object上的某个属性的值 参数 object (Object): 要检索的对象。 path (Array|string): 要获取属性的路径。 [defaultValue](*): 如果解析值是 undefined ，这值会被返回。 返回(*): 返回解析的值。 12345678// 引入：import get from &apos;lodash/get&apos;// 应用 searchByClassName().then((res) =&gt; &#123; const &#123; classes &#125; = get(res, &apos;data.data&apos;); this.classes = classes;&#125;) 具体实现方法可参考这篇文章:https://segmentfault.com/a/1190000015605531 二、ES6中的常用方法 Object.assign() Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。 123456例1：const source1 = &#123; b: 2 &#125;;const source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; 123456789例2： fetchData(config = &#123;&#125;) &#123; getList(Object.assign(&#123;page:this.page&#125;, config)).then(res =&gt; &#123; this.list = get(res, &apos;data.data.logs&apos; &#125;) .catch(() =&gt; &#123; &#125;) &#125; Object.keys(obj) Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。 Array.includes() 123456789101112router.beforeEach((to, from, next) =&gt; &#123; const paths = [&apos;/login&apos;,&apos;/register&apos;,&apos;/register2&apos;,&apos;/resetPassword&apos;,&apos;/&apos;,&apos;/classCenter&apos;] //to即将进入的目标路由对象，from当前导航正要离开的路由， next : 下一步执行的函数钩子 if (paths.includes(to.path)) &#123; next() &#125; else &#123; // &#125;&#125; https://www.jb51.net/article/181750.htm 二、JS中的常用方法 find()","categories":[],"tags":[]},{"title":"vue实现复制文本功能","slug":"vue实现复制文本功能","date":"2019-12-30T08:06:01.000Z","updated":"2019-12-30T11:12:12.524Z","comments":true,"path":"2019/12/30/vue实现复制文本功能/","link":"","permalink":"https://sucj0301.github.io/2019/12/30/vue实现复制文本功能/","excerpt":"","text":"问题：写vue项目时想要个快速复制某个数据用的插件：vue-clipboard2 第一步：在项目中导入 1npm install --save vue-clipboard2 第二步：在main.js中引入 12import VueClipboard from &apos;vue-clipboard2&apos;Vue.use(VueClipboard) 第三步：在vue文件中使用 123456789101112&lt;el-table-column class-name=&quot;status-col&quot; label=&quot;uuid&quot; align=&quot;center&quot; show-overflow-tooltip // 当内容过长被隐藏时显示 tooltip &gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;span id=&quot;link&quot; v-clipboard:copy=&quot;scope.row.room_uuid&quot; v-clipboard:success=&quot;copy&quot; v-clipboard:error=&quot;onError&quot; :value=&quot;scope.row.room_uuid&quot;&gt; &#123;&#123; scope.row.room_uuid || &apos;null&apos; &#125;&#125; &lt;/span&gt; &lt;/template&gt; &lt;/el-table-column&gt; 12345678910111213141516methods: &#123; copy() &#123; this.$message(&#123; duration: 600, message: &apos;复制成功!&apos;, type: &apos;success&apos; &#125;) &#125;, onError() &#123; this.$message(&#123; duration: 600, message: &apos;复制失败!&apos;, type: &apos;error&apos; &#125;) &#125;, &#125; 说明 v-clipboard:copy=”复制内容” v-clipboard:success=”Copy(成功回调)” v-clipboard:error=”Error(失败回调)”","categories":[],"tags":[]},{"title":"防止浏览器自动填写用户名和密码","slug":"防止浏览器自动填写用户名和密码","date":"2019-12-30T03:57:31.000Z","updated":"2019-12-30T11:35:57.509Z","comments":true,"path":"2019/12/30/防止浏览器自动填写用户名和密码/","link":"","permalink":"https://sucj0301.github.io/2019/12/30/防止浏览器自动填写用户名和密码/","excerpt":"","text":"问题：退出登录后用户名和密码还是在input框里** autocomplete属性是HTML5的新属性，在input中autocomplete属性是默认开启的。 定义：autocomplete属性规范表单是否启用自动完成功能。自动完成允许浏览器对字段的输入，是基于之前输入过的值。 应用范围：autocomplete适用form，以及input类型的text、search、url、telephone、email、password、datepickers、range、color 属性值：on—-默认，启动自动完成 off—–禁用自动完成 扩展：禁止浏览器表单自动填充 普通文本框添加 autocomplete=”off” 1&lt;input type=&quot;text&quot; autocomplete=&quot;off&quot; name=&quot;userName&quot;/&gt; 密码输入框添加 autocomplete=”new-password”。 1&lt;input type=&quot;password&quot; autocomplete=&quot;new-password&quot; name=&quot;password&quot;/&gt; 如果是整个表单可以设置： 1&lt;form method=&quot;post&quot; action=&quot;/form&quot; autocomplete=&quot;off&quot;&gt;[…]&lt;/form&gt; 原文链接：https://zhidao.baidu.com/question/443274673.html?ivk_sa=1022817r&amp;qq-pf-to=pcqq.c2c 再贴一篇文章：https://blog.csdn.net/ltx06/article/details/68941699","categories":[],"tags":[]},{"title":"Ajax","slug":"Ajax","date":"2019-08-30T14:05:49.000Z","updated":"2019-11-12T01:56:51.050Z","comments":true,"path":"2019/08/30/Ajax/","link":"","permalink":"https://sucj0301.github.io/2019/08/30/Ajax/","excerpt":"","text":"1.介绍 异步的javascript和xml;用于浏览器和后台服务进行异步交互（传递信息） 2. 特点 不会导致页面的全局刷新就可以进行与后台的交互;交互需要在”查看元素 -&gt; 网络”中监控 3. 使用方式核心对象：XMLHttpRequest 12345678910111213141. 实例化 var xhr = new XMLHttpRequest();2. 设置请求 xhr.open(method,url); 3. 设置头信息 xhr.setRequestHeader()4. 设置体信息（method为post时候） xhr.send(data);5. 设置监听 xhr.onreadystatechange = function() &#123; this.readyState // 1 2 3 4 this.status // 200 404 500 this.response // 响应信息 &#125; 4. 常用属性 onreadystatechange : 存有处理服务器响应的函数 123xhr.onreadystatechange = function() &#123; &#125; readyState : 存有服务器响应的状态信息;每当 readyState 改变时，onreadystatechange 函数就会被执行。 readyState属性的值 状态 描述 0 请求未初始化（在调用 open() 之前） 1 请求已提出（调用 send() 之前） 2 请求已发送（这里通常可以从响应得到内容头部） 3 请求处理中（响应中通常有部分数据可用，但是服务器还没有完成响应） 4 请求已完成（可以访问服务器响应并使用它） 12345xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4) &#123; //从服务器的response获得数据 &#125;&#125; status 状态 描述 200 “OK” 404 未找到资源 500 后台异常 responseText : 可以通过 responseText 属性来获得字符串形式的响应数据 1234567xhr.onreadystatechange=function() &#123; if (xhr.readyState==4 &amp;&amp; xhr.status==200) &#123; document.getElementById(&quot;myDiv&quot;).innerHTML=xhr.responseText; &#125; &#125; 5. 关于原生Ajax、Jquery封装、axios之间区别参考这篇文章 get 和 post 的区别： get是从服务器上获取数据，post是向服务器传送数据。 Get在浏览器回退时是无害的，而Post会再次提交请求。 无害的意思只是数据不变。 幂等性：HTTP幂等方法，是指无论调用这个url多少次，都不会有不同的结果的HTTP方法。也就是不管你调用1次还是调用100次，1000次，结果都是一样的（前提是服务器端的数据没有被人为手动更改。比如说，你数据库中的数据被手动更改过，那两次调用的结果肯定是变化的） GET产生的URL地址可以被收藏为书签，而POST不可以。 GET请求会被浏览器主动cache,而POST不会，除非手动设置。 GET请求只能进行url编码，而Post支持多种编码方式。 GET 请求参数会被完整保留在浏览器历史记录里，而POST不会被保留 GET请求在URL中传送的参数是有长度限制的，而POST没有 对于参数的数据类型，GET只接受ASCII字符，post没有限制 GET比POST更不安全，因为参数直接暴露在url上，所以不能用来传递敏感信息 GET参数通过URL传递，POST放在请求体（request body）中。 原文链接","categories":[],"tags":[]},{"title":"JavaScript-DOM","slug":"JavaScript-DOM","date":"2019-08-28T00:43:30.000Z","updated":"2019-11-11T12:29:03.980Z","comments":true,"path":"2019/08/28/JavaScript-DOM/","link":"","permalink":"https://sucj0301.github.io/2019/08/28/JavaScript-DOM/","excerpt":"","text":"DOM —— js操作html的api 1. 在html中添加js代码 script标签内 示例： 1&lt;script src=&quot;https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js&quot;&gt;&lt;/script&gt; 2. 第三方js库【操作html】 1) 实例化（如何创建对象）1var one = document.getElementById(&quot;one&quot;); 2) API(在线文档) Node html中所有的内容都可以认为是节点，比如：doctype、html、head、注释、div内容”hello”、空格、回车都是节点 属性： 1) 获取节点基本信息的属性 1234567891011nodeType ELEMENT_NODE 1 TEXT_NODE 3 COMMENT_NODE 8 DOCUMENT_NODE 9nodeName document #document 文本 #text 元素 标签名大写 DIVnodeValue 文本，注释 内容 2) 表示层次结构的属性 12345678parentNodeparentElementownerDocument 当前元素所在的文档对象childNodesfirstChildlastChildnextSiblingpreviousSibling 方法： 1) 父节点调用的方法 1234appendChild()insertBefore(new,reference)replaceChild(new,old)removeChild() 2) 其他 1cloneNode([boolean]) //如果参数为true,表示深克隆 Document 文档，表示整个html文档或者xml文档，一般情况下一个html可以使用一个Document的实例来表示，即document 属性:body 、 head 、 title 方法： 1234567getElementById()getElementsByClassName();getElementsByTagName()getElementsByName()querySelector(选择器)querySelectorAll(选择器) Element 元素，html文档中的所有的元素都可以映射为一个Element实例 （body/div/p/span/table/form…） 属性： 123451) 元素属性相关的属性 : id 、className 自有属性 ： name 、 href 、 src 、 alt 、 target ... 自定义属性 : 1234567892) 元素层次结构相关属性 children firstElementChild lastElementChild nextElementSibling previousElementSibling innerHTML // 获取或设置一个元素内的html内容 innerText // 获取或设置一个元素内的文本内容 方法: 12345属性相关:getAttribute(key)setAttribute(key,val)querySelector(选择器)querySelectorAll(选择器) Text 12文本内容,如下&quot;hello world&quot;表示文本内容&lt;div&gt;hello world&lt;/div&gt; Comment 1&lt;!-- 注释内容 --&gt;","categories":[],"tags":[]},{"title":"JavaScript-事件","slug":"JavaScript-事件","date":"2019-08-27T13:03:51.000Z","updated":"2019-11-11T12:02:29.207Z","comments":true,"path":"2019/08/27/JavaScript-事件/","link":"","permalink":"https://sucj0301.github.io/2019/08/27/JavaScript-事件/","excerpt":"","text":"1. 介绍 获取事件源 为事件源绑定事件处理函数 事件类型：click 、focus 、blur 、submit 、mouseover 、mouseout 、… 事件处理函数： 当绑定的事件类型被触发的时候该函数执行 从事件对象中获取事件详细信息 当事件处理函数执行的时候，dom会将事件对象传递给事件处理函数 2. 事件流 前提条件：元素嵌套；每层元素上绑定事件 1234567&lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;center&quot;&gt; &lt;div class=&quot;inner&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 2.1 事件捕获 外层-&gt;内层 2.2 事件冒泡（默认事件执行顺序） 内层-&gt;外层 3. 事件对象 target: 目标对象，用户操作的那个dom对象 currentTarget: 当前目标对象，表示事件处理函数绑定的那个dom对象 stopPropagation() : 停止冒泡 preventDefault() : 阻止默认行为 keyCode : 按键值 … 4. 事件类型 事件 描述 click 单击触发 dbclick 双击触发 keyup 按键抬起触发 keydown 按键放下触发触发 keypress 按下按键时触发 focus 聚焦时触发 blur 失去焦点时触发 mouseup 松开鼠标按键（左、右键均可）时触发 mousedown 按下鼠标按键（左、右键均可）时触发 mouseover 光标移动到元素上，支持子元素 mouseout 光标移出元素，支持子元素 mouseenter 光标移动到元素上，不支持子元素 mouseleave 光标移出元素，不支持子元素 onload window.onload 当前页面中的内容加载完毕 5. 事件代理 将事件绑定在当前元素的父元素上而非当前元素上，这时候当点击当前元素的时候，执行父元素上绑定的事件处理函数，可以通过event.target获取当前元素。 好处： 父元素代理子元素所有的事件，子元素可以动态添加和删除而不用频繁绑定事 6. 事件绑定的方式 onxxx 属性，简单，兼容性比较好 addEventListenner、removeEventListener 方法，非IE低版本才能兼容 attachEvent、detachEvent、 方法，IE低版本下才能兼容","categories":[],"tags":[]},{"title":"JavaScript-包装器","slug":"JavaScript-包装器","date":"2019-08-26T09:25:49.000Z","updated":"2019-11-11T11:46:30.467Z","comments":true,"path":"2019/08/26/JavaScript-包装器/","link":"","permalink":"https://sucj0301.github.io/2019/08/26/JavaScript-包装器/","excerpt":"","text":"包装器类型 Number 、 Boolean 、 String StringString.prototype.xxx length : 获取字符串中字数的数量 charAt(index) : 获取指定索引处的字符 charCodeAt(index) : 获取指定索引处的字符编码 indexOf() : 获取指定字符在字符串中索引 lastIndexOf() : 获取指定字符在字符串中的索引，【从后往前】 concat() : 连接两个字符串 slice(begin,end) : 截取子字符串，begin开始位置，end结束位置，不包含结束位置 substring(begin,end) : 截取子字符串，begin开始位置，end结束位置，不包含结束位置 substr(begin,length) : 截取子字符串，begin开始位置，length截取的字符的个数 trim() : 删除字符串左右两边的空格 toUpperCase() : 转换为大小 toLowerCase() : 转换为小写 对正则表达式支持的方法 search(regexp) 测试，类似于test()，不支持global返回值匹配内容的索引 match(regexp) 查找匹配的内容返回值数组，保存了匹配的内容 replace(regexp,xx) split(regexp)","categories":[],"tags":[]},{"title":"JavaScript-流程控制语句","slug":"JavaScript-流程控制语句","date":"2019-08-25T06:53:27.000Z","updated":"2019-11-11T11:13:50.394Z","comments":true,"path":"2019/08/25/JavaScript-流程控制语句/","link":"","permalink":"https://sucj0301.github.io/2019/08/25/JavaScript-流程控制语句/","excerpt":"","text":"1. 条件语句1) 分支语句123456789if (条件) &#123; // 条件为真时执行的代码&#125;if (条件) &#123; // 条件为真时执行的语句&#125; else &#123; 条件为假时执行的语句&#125; 示例 123if(w == &apos;下雨&apos;)&#123; console.log(&quot;带伞出门&quot;);&#125; 12345if(age &gt; 18)&#123; console.log(&quot;成年人&quot;);&#125; else &#123; console.log(&quot;未成年人&quot;);&#125; 2) 多分支语句123456789101112if( exp1 )&#123; exp2&#125; 当exp1为真的时候，执行exp2if(exp1)&#123; exp2&#125; else if(exp3)&#123; exp4&#125; else &#123; exp5&#125;当exp1为真，执行exp2,否则如果exp3为真执行exp4,否则z执行exp5 示例 123456789101112var day = 1;if(day == 1)&#123; console.log(&quot;周一&quot;);&#125; else if (day == 2)&#123; console.log(&quot;周二&quot;);&#125; else if (day == 3)&#123; console.log(&quot;周三&quot;);&#125; else if(day == 4)&#123; console.log(&quot;周四&quot;);&#125; else &#123; console.log(&quot;周末&quot;);&#125; 3) switch语句12345678910111213var day = 1;switch(day)&#123; case 常量1: // 代码1 break; case 常量2: // 代码2 break; ... default: // 代码d&#125;day === 常量1 ，如果为真，执行代码1，当遇到break，跳出switch代码块，结束运行；如果为假，继续判断 day===常量2， 示例 123456789101112switch(day)&#123; case 1: console.log(&quot;周一&quot;); break; case 2: console.log(&quot;周二&quot;); break; ... default: console.log(&quot;周末&quot;);&#125; 2.循环语句 三要素：初始化条件，结束判定条件，迭代 1. for循环语句123for(初始化条件; 结束判定条件; 迭代)&#123; 循环体&#125; 示例：计算出1到100累加的和 123456var result = 0;for(var i=1; i&lt;=100; i++)&#123; result += i;&#125;console.log(result); // 5050 2. 前置判断循环 while循环12345初始化条件while(结束判定条件)&#123; 循环体 迭代&#125; 示例：(同上) 12345var result = 0;var i = 1;while(i&lt;=100)&#123; result += i++;&#125; 3. 后置判断循环 do-while循环12345初始化条件do &#123; //循环体 迭代&#125; while(结束判定条件); 遍历数组 -&gt;使用for循环来对数组进行遍历 示例： 1234let arr = [1,2,3,4,5];for(let i=0;i&lt;arr.length;i++)&#123; console.log(arr[i]); &#125;","categories":[],"tags":[]},{"title":"JavaScript-运算符","slug":"JavaScript-运算符","date":"2019-08-24T03:23:45.000Z","updated":"2019-11-11T10:33:24.285Z","comments":true,"path":"2019/08/24/JavaScript-运算符/","link":"","permalink":"https://sucj0301.github.io/2019/08/24/JavaScript-运算符/","excerpt":"","text":"1) 算术操作符12345+ += - -=* *=/ /=% %= 2) 赋值操作符12345var result = 1 + 2;result += 3;==等价于==&gt; result = result + 3; 将1+2这个表达式的运算结果赋值给result 3) 一元运算符 ++ 自增 – 自减 前置：先自增、减再参与其他运算 后置：先参与其他运算，再自增、自减 1234567var a = 3;var b = 1;var result = ++a+b++;++a; // a = 4;a+b // result 5;b++ // b = 2; + 12345var a =3 ;+a;将其他数据类型转换为数字类型 +true //1 +&apos;11&apos; //11 - 1234-a;将其他数据类型转换为数字类型 -(-true) //1 -(-&apos;11&apos;) //11 4) 逻辑运算符 -短路运算符【返回结果不一定是boolean】 &amp;&amp; 当第一个表达式为假的时候，不再计算第二个表达式，整个表达式的结果由第一个表达式来决定，因此会返回第一个表达式的运算结果 12345var age = 12;gender = &quot;male&quot;age&gt;18 &amp;&amp; gender == &apos;male&apos; // false&quot;hello&quot; &amp;&amp; 1 //1 || 当第一个表达式为真的时候，整个表达式的结果就为真，不再计算第二个表达式。返回第一个表达式 null || &quot;hello&quot; //&quot;hello&quot; ! 123456!false // true!true // false!3 // false将其他数据类型转换为boolean!!3 // true 5) 比较运算符（比较栈区的值）【返回类型为Boolean】12345678910111213==!= 比较值 &apos;11&apos; == 11 // true 比较对象的时候比较的是对象的引用===!== 先比较数据类型，如果数据类型不一致，会直接返回false，如果数据类型一致，再比较值 &apos;11&apos; === 11 // false&gt;&gt;=&lt;&lt;= 6) 三目运算符1234567891011exp1 ? exp2 : exp3当exp1为真，返回exp2，否则返回exp3var result = age &gt; 18 ? &quot;成年人&quot; : &quot;未成年人&quot;==&gt;var result;if(age &gt; 18)&#123; result = &quot;成年人&quot;;&#125; else &#123; result = &quot;未成年人&quot;&#125; 7) 位运算符(number,先将number转换二进制再运算)1234异或 ^位与 &amp; 3 &amp; 4 位或 | &amp;&amp; 与 &amp; 的区别 &amp;运算符有两种用法：(1)按位与；(2)逻辑与。&amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。&amp;&amp;之所以称为短路运算是因为，如果&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&amp;&amp;而不是&amp;，例如在验证用户登录时判定用户名不是null而且不是空字符串，应当写为：username != null &amp;&amp;!username.equals(“”)，二者的顺序不能交换，更不能用&amp;运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，否则会产生NullPointerException异常。注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。 8) 拼接运算符 当使用 “+” ，操作数中出现了字符串，那么就肯定是拼接运算","categories":[],"tags":[]},{"title":"JavaScript-数组","slug":"JavaScript-数组","date":"2019-08-23T10:27:08.000Z","updated":"2019-11-11T10:03:13.345Z","comments":true,"path":"2019/08/23/JavaScript-数组/","link":"","permalink":"https://sucj0301.github.io/2019/08/23/JavaScript-数组/","excerpt":"","text":"1.作用 存放多个数据的集合； 数组的边界”[]”,数组的组成称为元素，元素与元素之间通过逗号隔开，元素的数据类型没有限制 2.定义方式 数组字面量 12var name = &quot;terry&quot;var arr = [name,1,true,&quot;hello&quot;,null,&#123;name:&quot;s&quot;&#125;,function()&#123;&#125;]; 构造函数 Array Array 继承 Object通过Array构造函数构建出来的对象可以调用Array原型中的方法，还可以调用Object原型中的方法 12345var arr = new Array();var arr = new Array(length);var arr = new Array(item1,item2,...);arr -&gt;Array.prototype-&gt; Object.prototype 3. 数组访问方式 中括号访问符，索引从0开始，如果指定索引的位置没有值，返回undefined 数组名[索引] 123456789101112131415161718192021var arr = [3,12,5,3];arr[1]+=1;var obj = &#123; name:&quot;terry&quot;, age:12, sayHello:function()&#123;&#125;&#125;obj.sayHello();var arr = [ &quot;terry&quot;, 12, function()&#123;&#125;]arr[2]()=&gt;var arr = &#123; &quot;0&quot;:&quot;terry&quot;, &quot;1&quot;:12&#125;arr[&quot;0&quot;] 4.数组内存1var arr = [&quot;terry&quot;,12,[1,2,3]]; arr是变量，保存在栈区 arr是引用数据类型的变量，栈区保存的引用地址，数组的值保存在堆区 12345678var arr = [&quot;terry&quot;,12,&#123;name:&quot;terry&quot;,age:12&#125;];var a = arr[1];a++;console.log(arr[1]); //12var b = arr[2]b.age++;console.log(arr[2].age); //13 5.数组的属性 数组也是一种对象，length是表示数组长度的属性，length表示数组中元素的个数 6.数组的遍历(循环遍历索引)123456789101112var arr = [1,2,3,4,5];1) 使用for循环for(var i = 0 ; i&lt;arr.length; i++)&#123; var val =arr[i] console.log(val);&#125;2) 使用while3) 使用do-while4) 使用增强for循环 for(var key in arr)&#123; var val = arr[key] &#125; 7.数组相关的API12var obj = new Object();var arr = new Array(); Array() 构造函数（类）arr 实例（对象） 注：实例可以调用构造函数原型中的方法 1) 添加元素移除元素相关【改变原值】 方法 参数 返回值 描述 push(p1,p2,…); 要入栈的元素 数组长度 入栈，在数组的最后添加一个元素 pop(); none 出栈的元素 出栈，从数组的最后取出一个元素 shift(); none 出队的元素 出队，将数组中第一个元素取出来 unshift(p1,p2,…); 要插队的元素 插队后队列的长度 插队，将元素插入在数组的最前面 2) 排序方法【改变原值】 sort(); //按照字符在字符编码表中出现的位置进行排序 sort(comparator); //comparator为一个比较器函数，函数可以接受两个值a,b；当a位于b之前的时候返回 3) 序列化方法 toString(); //将数组转换为字符串，数组中的元素通过逗号连接 join(v); //将数组转换为字符串，数组中的元素通过v连接 JSON.stringify(); //将数组转换为JSON字符串 arr -&gt; Array.prototype -&gt; Object.prototype 1234var arr = [&quot;terry&quot;,&quot;larry&quot;]arr.toString(); Array.prototype Object.prototype 123 让Object.prototype中的toString转换arr=&gt;[&quot;terry&quot;,&quot;larry&quot;].toString(); 4) 截取方法 方法名 参数 返回值 描述 concat() 多个数组 合并后的数组 （不改变原值）将参数中的数组和当前数组合并为一个数组 slice（begin,end） begin 起始位置；end 结束位置 截取到的子数组 （不改变原值）从当前数组中截取一个子数组并且范围 splice(begin,delete[,p1,p2,…]) begin 起始位置；delete 删除的个数；p1,p2..为插入的值 删除的元素组成的数组 从数组中删除、插入、更新元素 5) 迭代方法 方法 返回值 描述 forEach(function(item,index,arr){}) 元素，索引，数组 遍历当前数组 every(function(item,index,arr){}) 与回调函数返回值相同，true或false 判断数组中所有的元素是否满足回调函数中给定的条件 some(function(item,index,arr){}) 回调函数每次返回值都是false，就是false；否则都为true 判断数组中是否有满足条件的元素 filter(function(item,index,arr){}) 回调函数为true，当前元素就会添加到返回值数组中 过滤 map(function(item,index,arr){}) 回调函数中的值都会添加到返回值数组 遍历 6) 查找方法 indexOf(); //返回某个指定的字符串值在字符串中首次出现的位置（索引值） （从前往后查） lastIndexOf(); //从右向左查某个指定的字符串在字符串中最后一次出现的位置（从后往前查）","categories":[],"tags":[]},{"title":"JavaScript-函数(Function)","slug":"JavaScript-函数","date":"2019-08-22T11:25:02.000Z","updated":"2019-11-11T08:41:55.137Z","comments":true,"path":"2019/08/22/JavaScript-函数/","link":"","permalink":"https://sucj0301.github.io/2019/08/22/JavaScript-函数/","excerpt":"","text":"1.函数的用处 使用函数封装某些功能代码，执行特定功能 arr.sort() 排序 arr.reverse() 数组反转 jQuery() 调用jquery函数完成特定功能 … 使用函数封装创建对象的模板【构造函数】面向对象 2.函数的使用（功能） 1) 函数的定义 函数声明 123function 函数名(形参) &#123; 函数体&#125; 函数表达式 123456789var 函数名 = function(形参)&#123;&#125;sayHello();var sayHello = function()&#123;&#125;console.log(a);var a = 3; 2)函数的调用 函数名(实参) 函数名.call(this,实参列表); 函数名.apply(this,实参数组); 注：函数声明会提升如果一个函数使用函数声明的方式来定义，那么在函数定义之前就可以调用该函数 3.函数的作用域 如果一个变量声明在函数中，那么这个变量只能在函数中访问，当函数执行完毕后，这个变量就会被释放掉。 123456789nodejs ECMAScript（var） var不存在局部作用域 function foo()&#123; if(true)&#123; // 局部作用域，a只能在当前代码块生效 var a = 3; &#125; console.log(a); &#125; 注：如果该代码运行在nodejs中，a访问不到，但是如果运行在浏览器中，a的值为3。 4.函数内部属性 只能在函数运行的时候才能确定的属性，只能在函数内部访问。 12345function add(a,b)&#123; var result = a + b; return result;&#125;add(32,22,19); 1) 形参 123 function foo(形参1，形参2...) &#123;&#125; 2) arguments : 接受实参的真正所在，类数组对象 123456arguments:&#123; 0:32, 1:22, 2:10, length:3&#125; 3) this : 当前对象（环境对象） 如何判断this的值为谁： this的取值与该函数的调用方式有关1) 如果函数使用”()”来调用，那看一下括号前面是不是函数名，如果是，看函数名前面有没有对象，如果有，this指向该对象，否则指向全局对象（window/global）2) 如果通过call,apply来调用，this为用户手动指向的那么对象 详细可看此文章 练习： 123456789101112131415var p1 = &#123; name:&quot;terry&quot;, age:12, sayName:foo&#125;var p2 = &#123; name:&quot;larry&quot;, age :12, sayName:foo&#125;// 当执行p1.sayName()打印“hello my name is terry”，执行p2.sayName()打印“hello my name is larry”,foo函数如何定义function foo()&#123; console.log(&quot;hello my name is &quot;+this.name);&#125; 5.值传递和引用传递1234567891011var a = 3;var b = a; //b 为3 值拷贝b++console.log(a);var a = &#123;name:&quot;terry&quot;,age:12&#125;;var b = a; // a为指针，b为指针 引用拷贝b.age++;console.log(a.age);","categories":[],"tags":[]},{"title":"JavaScript-对象","slug":"JavaScript-对象","date":"2019-08-21T09:24:46.000Z","updated":"2019-11-11T08:16:44.234Z","comments":true,"path":"2019/08/21/JavaScript-对象/","link":"","permalink":"https://sucj0301.github.io/2019/08/21/JavaScript-对象/","excerpt":"","text":"1.介绍 复杂的数据类型，引用数据类型，一般情况下，对象中包含了多个属性和方法。 2.对象创建方式1)对象字面量 对象使用”{}”作为边界，对象是由多个属性(方法是一种特殊的属性)来组成，每个属性之间通过”,”分割，属性名与属性值之间通过”:”分割。属性名可以不使用双引号，当属性名中包含特殊字符一定使用双引号，属性值一般为常量或者具体的值，也可以变量 1234567var obj = &#123; name:&quot;terry&quot;, age:12, sayName:function()&#123; &#125;&#125;; 2)使用构造函数构建对象123456789var obj = new Object();obj.name = &quot;terry&quot;;obj.age = 12;=&gt;var obj = &#123;&#125;;obj.name = &quot;terry&quot;;obj.age = 12;...var obj = &#123;&#125;; Object是所有对象的根对象，一个普通对象都会直接间接的继承Object 3.属性的访问 点访问符 对象名.属性名 obj.name 中括号访问符 1234var name = &quot;name&quot;;obj[name]=&gt;obj[&quot;name&quot;] 4.所有的对象直接或者间接的继承Object，也就是说所有的对象都可以调用Object原型中的方法和属性。 Object.prototype.xxx 123456constructor 构造函数，谁创建了当前对象hasOwnProperty(prop) 判断某个属性是否属于当前对象的自有属性propertyIsEnumerable(prop) 检测某个属性是否可以被枚举isPrototypeOf(prop) 检测某个属性是否是原型链中的属性toString(); 返回该对象的字符串描述信息valueOf(); 返回该对象的数字描述信息 5.删除属性delete obj1.name 6.对象序列化和返序列化var obj = {name:&quot;terry&quot;}; 将js对象转换为json字符串 var json = JSON.stringify(obj) 将json字符串转换js对象 var obj = JSON.parse(json); 7.对象的遍历12345678910var obj = &#123; name:&quot;terry&quot;, age:12&#125;var arr = [&quot;terry&quot;,&quot;larry&quot;];for(var key in obj)&#123; //如何获取属性值 var value = obj[key]&#125; obj可以为对象或者数组；key表示对象的属性名或者是数组的索引；在运行的时候，每次从obj中获取一个属性名或者索引赋值给key，然后执行循环体，循环… 8.in关键字 prop in obj : 检测prop是否可以被obj调用","categories":[],"tags":[]},{"title":"JavaScript---变量","slug":"JavaScript-变量","date":"2019-08-20T02:04:06.000Z","updated":"2019-11-11T08:05:36.167Z","comments":true,"path":"2019/08/20/JavaScript-变量/","link":"","permalink":"https://sucj0301.github.io/2019/08/20/JavaScript-变量/","excerpt":"","text":"JavaScript的特点：解释型脚本语言、弱类型语言、事件驱动型语言、交互性、安全性、平台无关性(跨平台) 一、变量的声明123456var a ; // 变量的声明 a = 3 ; // 变量的初始化=&gt;var a = 3 ; //声明和初始化一起 二、变量的类型1.基本数据类型 ① 数字类型 number 1234var a = 3 ; var a = 3.0 ;var a = 011 ;var a = 0x11 ; ② 字符串类型 string 123var str = &quot;hello world&quot;;var str = &apos;hello js&apos;;var str = &apos;&#123;&quot;name&quot;:&quot;sucj&quot;&#125;&apos; ③ 布尔型 boolean 12var b = true ;var b = false ; ④ 空 null 12一般表示空对象var a = null ; ⑤ 未定义 undefined 12var a ; // undefinedvar a = undefined ; // undefined ⑥ 独一无二 Symbol （ES6新增的） 12345678910 let s = Symbol(); typeof s ; // &quot;Symbol&quot;或 let s1 = Symbol(&apos;foo&apos;); s1; // Symbol(foo) s1.toString(); 2.数据类型检测 【typeof】能检测的类型有：number、boolean、string、symbol、object、undefined、function 123456typeof Symbol(); // symboltypeof 1; // numbertypeof &quot;abc&quot;; // stringtypeof null; // objecttypeof []; // objecttypeof &#123;&#125;; // object 注：typeof检测数组或对象都是返回object，所以主要是用来检测基本数据类型 【instanceof】用来判断A是否为B的实例，表达式为：A instanceof B。如果A是B的实例，则返回true，否则返回false。【instanceof】运算符实际上是用来测试一个对象在其原型链中是否存在一个构造函数的prototype属性的。 12345[] instanceof Array; // true&#123;&#125; instanceof Object; // truenew RegExp() instanceof RegExp; // true 【isArray】判断是否是数组 【isNaN】判断是否不是数字类型 123isNaN(result) 3/&quot;a&quot; 如果result是NaN,那么这个函数返回true 【isFinite】判断是否是一个有穷数 123isFinite(result)如果result是一个有穷数，返回true3/0 =&gt; inFinite 无穷数 2.引用数据类型 包括Object、Array、Function、Date、Math、RegExp、Error(具体的后面会写笔记)","categories":[],"tags":[]},{"title":"Linux(ubuntu16.04)","slug":"Linux-ubuntu16-04","date":"2019-08-17T00:55:26.000Z","updated":"2019-10-28T12:01:53.993Z","comments":true,"path":"2019/08/17/Linux-ubuntu16-04/","link":"","permalink":"https://sucj0301.github.io/2019/08/17/Linux-ubuntu16-04/","excerpt":"","text":"一、Linux简介&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Linux是一种自由和开放源码的操作系统，有很多不同的版本，比如RedHat、SuSE、Ubuntu、Fedora、GentOS等等，它可以安装在手机、平板电脑、路由器、台式计算机等各种计算机硬件设备中。 二、Linux特点 开源免费 安全稳定 多用户多任务 广泛的硬件支持 模块化程度高 良好的移植性 三、Linux的使用1.用户管理 在学习Linux命令之前要了解的东西： /etc/passwd和/etc/shadow(保存Linux用户名和密码的两个重要文件) 1)/etc/passwd内容格式说明(冒号隔开算一列) 例：root:x:0:0:root:/root:/bin/bash 列数 含义 说明 1 用户名 是UID字符串标记方式，方便阅读 2 密码 保存在/etc/shadow中，此处用x表示 3 UID 用户的数字ID 4 GID 用户组的数字ID 5 说明栏 类似于注释， 6 家目录 用户登录后所处的目录 7 登录Shell 用户登录后所使用的Shell 2)/etc/shadow内容格式说明 例：sucj:$6$FR/sXSFK$Bn0sk/DBW1F1ybfjIutSMWS4tMKwtHOP4NR/KCW833JonmuDhEVfTXAW7ylpRnAC0bi.qPj1XgoBCqTnOubbL/:18123:0:99999:7::: 列数 含义 说明 1 用户名 是UID字符串标记方式，方便阅读 2 密码 经过加密后的密码 3 密码的最近修改日期 从1970年1月1日到密码修改日的天数 5 密码不可修改的天数 修改密码之后，几天内不可修改，如果是0，则可以随时修改 6 密码重新修改的天数 密码修改时间，在密码到期之前会提醒用户修改密码 7 密码失效前提前警告的天数 设定密码到期前几天内提醒用户修改密码 8 账号失效日期 一般为空 9 保留字段 暂时没有使用 一些关键字和符号 关键字/符号 含义 root 超级管理员（至高无上的权限） ~$ 说明当前是root用户 ~# 说明当前是普通用户 1)创建新用户 命令 描述 adduser xxx 新建用户xxx 过程 新建组，组名与用户名保持一致/etc/group 保存了组信息 新建用户，并且将用户当道刚刚新建的组中/etc/passwd 保存了用户信息/etc/shadow 保存了用户的密码信息 创建了一个家目录 /home/xxx 拷贝到用户家目录 etc/skel 2)删除用户 命令 描述 userdel xxx 删除用户信息 userdel -r xxx 删除用户信息，并且将用户家目录和邮件信息 3)切换用户 命令 描述 su 切换到root用户，但用户环境是切换前的用户的环境 su - 切换到root用户，并且应用root的用户环境 su xxx 切换到普通用户xxx，但用户环境是root的用户环境 su - xxx 切换到普通用户xxx，并且用户环境是xxx的用户环境 exit 直接返回到上次使用的用户 4)修改密码 命令 描述 ~$ passwd xxx 修改用户xxx的密码(密码可以很简单且无需知道xxx当前密码) ~# passwd 修改自己的密码(普通用户也可以),需提供当前密码且新密码不能太简单 5)修改用户 可以先用命令cat /etc/passwd | grep xxx 查看用户xxx当前所在目录 命令 描述 使用方法 usermod -d 修改用户家目录 usermod -d /home/xxx-n -m xxx(-m参数的作用是如果指定的用户家目录不存在，就自动创建新目录xxx-n，并使用该目录作为xxx 的新家目录，如果没有这个参数则会报错) usermod -g 修改用户组ID usermod -g 1008 zhangsan(将zhangsan的组ID换成1008) usermod -L 冻结账号(账号出现异常时可使用) usermod -L xxx(被冻结的账号在第二列也就是密码最前面有个感叹号) 6)修改组信息 命令 描述 groupadd group1 创建一个组名为group1的组 groupdel group1 删除组group1 groupmod -n group2 group1 把组名group1改为group2 groupmod -g 333 group1 把组group1的数字ID改为333 7)检查用户信息 命令 描述 users 查看当前系统有哪些用户 who 查看当前系统的用户以及它们的登录终端、登录时间 w (比上两个命令更详细的信息，见下表) finger 显示系统登录用户的信息，后可跟某个用户名以显示该用户更详细的信息 其中w显示的信息： 列数 列名 说明 1 USER 登录用户的用户名 2 TTY 用户登录终端 3 FROM 如果用户从网络登录，则显示远程主机的主机名或IP地址 4 LOGIN@ 用户登录时间 5 IDLE 用户闲置时间 6 JCPU 与终端相关的当前所有运行进程消耗的CPU时间总量 7 PCPU 当前WHAT列所对应的进程所消耗的CPU时间总量 8 WHAT 用户当前运行的进程 2.Linux的目录结构 目录 目录的用途 /home 普通用户的家目录(默认情况下普通用户只能在用户家目录中进行更新操作) /root root用户的家目录 /etc 系统配置文件的目录 /opt 第三方软件解压安装的目录 /usr 存放与用户直接相关的文件和目录(文件的默认目录) /var 存放那些在时间、大小、内容上会经常变化的文件(比如日志文件) /sys 系统目录，用于存放系统信息 /dev 设备文件，包括硬盘和显示器 /bin 常见的用户指令 /boot 内核和启动文件 /lib 系统函数库目录 /lost+found ext3文件系统需要的目录，用于磁盘检查 /mnt 用于加载各种文件系统 /proc 虚拟文件系统 /sbin 存放系统管理命令 /tmp 临时文件的存放目录 /media 用来加载各种媒体等临时文件的挂载点 绝对路径和相对路径 绝对路径：从根目录开始的全路径，一定是以 / 开头(比如/usr/local/src) 当前目录：可使用命令pwd查看 特殊目录：(.)和(..) 一个点(.)代表当前目录 两个点(..)代表当前目录的上层目录 相对路径：相对于当前路径的路径。比如 cd . 表示进入当前目录 cd .. 表示进入当前目录的上层目录 3.文件系统1、新建目录 命令 描述 mkdir linux es5 es6 在当前目录下创建多个文件 mkdir -p day/a/b/c 在多个嵌套文件夹中创建文件 2、新建文件/修改最近访问时间 touch 文件名 ： 如果指定的文件名不在，创建该文件。如果存在，修改最近访问时间为当前时间 3、拷贝文件或者目录 命令 描述 cp a.txt /tmp/a-copy.txt 把文件a.txt复制到文件夹/tmp并命名为a-copy.txt cp a.txt /tmp/ 把文件复制到文件夹/tmp但保持原文件名不变 cp -r dir1 dir2 将dir1目录复制成dir2目录 4、链接 命令 描述 $ ln a.txt a.txt.h 创建硬链接(防止误删除，多个指针指向同一个inode) $ ln -s a.txt a.txt.s 创建软链接 (快捷方式) 5、移动和重命名 命令 描述 mv a.txt /mnt/ 移动文件a.txt到目录/mnt中 mv a.* dir1 将前缀为a的所有文件移动到文件夹dir1中 mv a.txt a.doc 将文件a.txt重命名为a.doc 6、删除文件 命令 描述 rm a.txt 删除a.txt文件 rm -r dir1 删除dir1文件夹 rmdir dir2 删除文件夹dir2，前提是dir2一定是空文件夹 7、重定向 命令 描述 date &gt; a.txt 将当前时间打印到a.txt中，如果a.txt中有内容则会被覆盖 date &gt;&gt; a.txt 将当前时间打印到a.txt中，如果a.txt中有内容则回追加在后面 more /etc/passwd &gt; b.txt 将/etc目录下的passwd中的内容打印到b.txt中 ls -l /etc &gt; c.txt 将/etc目录下的内容以长内容形式打印到c.txt中 8、压缩与解压 压缩形式 含义 压缩后的文件后缀名 解压方法 gzip a.txt 压缩文件a.txt .gz gunzip a.txt.gz bzip2 b.txt 压缩文件b.txt .bz2 bunzip2 b.txt.bz2 zip all.zip *.txt 打包压缩 .zip unzip all.zip 打包压缩zip后紧跟的是压缩后的包名(自己命名)，再后面是要压缩的文件，可以压缩多个文件和目录，用空格隔开列出即可。如果要压缩目录，记得在zip后加 -r 参数。 9、归档和拆档(tar) 归档： 参数 含义 -c 创建归档文件 -x 拆档 -v 打印细节 -f 指定归档/拆档文件 -j bzip2格式 (xxx.tar.bz2) -z gzip格式 (xxx.tar.gz) 使用方法 命令 描述 tar cvf all.tar *.txt 将后缀名为.txt的文件归档为all.tar,并打印细节 tar cvzf all.tar.gz *.txt 将后缀名为.txt的文件归档为all.tar,并且压缩格式为gzip，打印细节 tar cvjf all.tar.bz2 *.txt 将后缀名为.txt的文件归档为all.tar，并且压缩格式为bzip2，打印细节 拆档：tar xvf all.tar.gz 10、其它命令 命令 描述 clear 清理终端屏幕 ls /home 列出价目录的所有目录和文件 ls -l 列出每个文件的详细信息 ls -a 同时列出隐藏文件 ls -al 格式化地输出文件的详细信息 ls -lrt 按时间显示文件 man 查看指定命令的手册，q代表退出手册，回车代表下一行，空格代表下一页 more 预览(不支持后退，所以在不需要后退的情况下使用比较方便) less 预览(支持前后翻滚，可以向上翻页&lt;PgUp键&gt;,也可以向下翻页&lt;PgDn键&gt;) head -n file1 查看一个文件的前n行，不加-n默认查看前十行 tail -n file1 查看一个文件的后n行，不加-n默认查看后十行 cat 查看文件的内容（链接后显示） tac 把内容反过来显示(最后一行先显示，第一行最后显示) nl 给输出的文件内容添加行号后显示 cd 或 cd ~ 回到家目录 cd / 切换到根目录 cd .. 返回上一级目录 cd ../.. 返回上两级目录 cd - 返回上次所在目录 cd /home/zhangsan 切换到指定目录 pwd 输出当前目录地址 grep str /tmp 在tmp目录下查找”str” Linux的一些很可爱的快捷键： 快捷键 作用 Ctrl + u 删除光标前(含光标所在字符)到行首的字符(在输错命令但Backspace啥的都用不了的时候，真的绝了) Ctrl + k 删除光标后(含光标所在字符)到行尾的字符 Esc + Backspace 删除当前光标前全部命令，但是有的情况下用不了，不喜欢 Ctrl + C 终止前台运行的程序(取消当前输入的命令) Ctrl + D 退出，相当于exit(返回) Ctrl + a 光标移动到行首 Ctrl + e 光标移动到行尾 Ctrl + l 清屏,也可以是Ctrl + L Tab 补全命令(只能补全命令和文件)，在命令没输全时按两下会给出所有以此开头的命令 ！$ 引用上一个命令的最后一个参数 ！后面遇到再补充","categories":[],"tags":[]},{"title":"css3--布局","slug":"css3-布局","date":"2019-08-15T12:13:19.000Z","updated":"2019-11-06T12:39:41.174Z","comments":true,"path":"2019/08/15/css3-布局/","link":"","permalink":"https://sucj0301.github.io/2019/08/15/css3-布局/","excerpt":"","text":"一、浮动布局 float:left/right; 脱离文档流: 1）高度和宽度默认由内容决定 2）原先所在位置就会被其他块元素抢占 3）浮动元素在一行中依次排列，当一行无法容纳的时候会自动换行 应用： 全部浮动 （2列以上） 12345678910111213141516171819&lt;style&gt; ul::after&#123; display:block; content: &quot;&quot;; clear: both; &#125; ul &gt; li &#123; float: left; width: (自己设置); &#125;&lt;/style&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/body&gt; 左侧浮动，右侧不浮动（2列） 123456789101112131415&lt;style&gt; .content &gt; .left &#123; float: left; width: 220px; &#125; .content &gt; .right &#123; margin-left: 230px; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;content&quot;&gt; &lt;div class=&quot;left&quot;&gt;&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 二、定位布局 1）作用：当一个元素悬挂在其他元素之上，优先考虑定位布局eg：模态框、下拉菜单、二级菜单、固定宣传栏、网页聊天页面 2）用法：position:static / relative / absolute / fixed / sticky ; static : 默认，静态布局，默认文档流中，非定位元素 relative ： 定位元素（相对定位） 1）没有脱离文档流 2）参照点为当前元素原本的位置 absolute ： 定位元素（绝对定位） 1）脱离了文档流 2）参照距离当前元素最近的父定位元素，如果所有的父元素都没有定位元素，则参照浏览器视口 fixed ： 定位元素（固定定位） 1）脱离了文档流2）参照浏览器视口 sticky ： 定位元素（粘滞定位） 1）不脱离文档流2）relative 和 fixed 的结合 例：top:50px; //当当前元素距离浏览器视口顶端为50px时，体现fixed的特点。 定位元素的特点： 1.可以使用描述当前元素位置的属性 top、right、bottom、left 2.z-index 指定一个元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。 1234567img &#123; position:absolute; left:0px; top:0px; z-index:-1; &#125; 3.参照点 4.是否脱离文档流 练习 相对定位 123456789101112131415161718192021222324252627282930313233&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;相对定位&lt;/title&gt; &lt;style&gt; .outer &#123; background-color: #ccc; &#125; .outer &gt; div &#123; height: 100px; &#125; .outer &gt; div.one &#123; background-color: lightblue; &#125; .outer &gt; div.two &#123; background-color: pink; position: relative; top: 50px; left: 50px; z-index: 1; &#125; .outer &gt; div.three &#123; background-color: teal; position: relative; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;one&quot;&gt;&lt;/div&gt; &lt;div class=&quot;two&quot;&gt;&lt;/div&gt; &lt;div class=&quot;three&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 绝对定位 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;绝对定位&lt;/title&gt; &lt;style&gt; body &#123; &#125; .outer &#123; background-color: #ccc; width: 800px; margin: 100px auto; position: relative; &#125; .outer &gt; div:nth-child(1), .outer &gt; div:nth-child(3) &#123; height: 100px; &#125; .outer &gt; div.one &#123; background-color: lightblue; &#125; .outer &gt; div.two &#123; background-color: pink; position: absolute; /*width: 100px;*/ top: 0; left: 0; right: 0; bottom: 0; opacity: .5; &#125; .outer &gt; div.three &#123; background-color: teal; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;one&quot;&gt;&lt;/div&gt; &lt;div class=&quot;two&quot;&gt;&lt;/div&gt; &lt;div class=&quot;three&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 固定定位 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;固定定位&lt;/title&gt; &lt;style&gt; p &#123; margin: 0; &#125; ul &#123; margin: 0; padding: 0; list-style: none; &#125; .container &#123; &#125; .aside &#123; position: sticky; float: right;; width: 100px; background-color: pink; top: 200px; &#125; .aside &gt; ul &gt; li &#123; height: 100px; line-height: 100px; border-bottom: 1px solid #fff; position: relative; &#125; .aside &gt; ul &gt; li:hover &gt; div &#123; display: block; &#125; .aside &gt; ul &gt; li &gt; div &#123; background-color: teal; width: 200px; position: absolute; top: 0; right: 120px; display: none; &#125; .wrapper &#123; width: 1200px; margin: 0 auto; &#125; a &#123; text-decoration: none; &#125; .top_nav a&#123; color: #333; font-weight: bold; &#125; .top_nav ul.nav &#123; background-color: teal; position: relative; &#125; .top_nav ul.nav::after &#123; display: block; content: &quot;&quot;; clear: both; &#125; .top_nav ul.nav &gt; li &#123; float: left; width: 100px; text-align: center; &#125; .top_nav ul.nav &gt; li:hover &gt; div &#123; display: block; &#125; .top_nav ul.nav &gt; li &gt; div &#123; position: absolute; left: 0; top: 100%; width: 100%; height: 200px; background-color: #fff; display: none; &#125; .left-aside &#123; position: fixed; left: 0; top: 200px; width: 100px; background-color: pink; &#125; .left-aside &gt; div &#123; height: 100px; line-height: 100px; border-bottom: 1px solid #fff; &#125; .left-aside &gt; div:hover &gt; div&#123; display: block; &#125; .left-aside &gt; div &gt; div&#123; position: absolute; top: 0; left: 100%; width: 300px; background-color: #ededed; display: none; height: 300px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;top_nav&quot;&gt; &lt;div class=&quot;wrapper&quot;&gt; &lt;ul class=&quot;nav&quot;&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;居家生活&lt;/a&gt; &lt;div&gt; 居家生活子元素 &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;服饰鞋包&lt;/a&gt; &lt;div&gt; 服饰鞋包子元素 &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;美食酒水&lt;/a&gt; &lt;div&gt; 美食酒水子元素 &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;运动旅行&lt;/a&gt; &lt;div&gt; 运动旅行子元素 &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;div style=&quot;height: 300px;background-color: lightblue&quot;&gt; &lt;/div&gt; &lt;div class=&quot;left-aside&quot;&gt; &lt;div&gt; &lt;p&gt;全站&lt;/p&gt; &lt;div&gt; 全站... &lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt;居家&lt;/p&gt; &lt;div&gt; 居家.... &lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt;服饰&lt;/p&gt; &lt;div&gt; 服饰... &lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;p&gt;美食&lt;/p&gt; &lt;div&gt; 美食... &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 右侧栏 --&gt; &lt;div class=&quot;aside&quot;&gt; &lt;ul&gt; &lt;li&gt;图片&lt;/li&gt; &lt;li&gt;二维码&lt;/li&gt; &lt;li&gt; &lt;p&gt;电子刊&lt;/p&gt; &lt;div&gt; 电子刊子内容 &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;p&gt;客服&lt;/p&gt; &lt;div&gt; 客服子内容 &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;br&gt;*100 //做测试&lt;/body&gt; 粘滞定位 eg1: 123456789101112131415161718192021&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;粘滞布局&lt;/title&gt; &lt;style&gt; div:nth-child(3)&#123; background-color: pink; position: sticky; top: 20px; width: 200px; right: 0; float: right; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div style=&quot;height: 200px;background-color: #ededed&quot;&gt;&lt;/div&gt; &lt;div&gt;one&lt;/div&gt; &lt;div&gt;two&lt;/div&gt; &lt;div&gt;three&lt;/div&gt; &lt;div style=&quot;height: 2000px;background-color: #ccc&quot;&gt;&lt;/div&gt;&lt;/body&gt; eg2: 1234567891011121314151617181920212223&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;粘滞定位&lt;/title&gt; &lt;style&gt; body &#123; margin: 0; &#125; .box &#123; height: 100px; width: 100px; background-color: #ededed; position: sticky; top:50px; float: right; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div style=&quot;height: 300px;background-color: pink&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;div style=&quot;height: 1000px;background-color: lightblue;&quot;&gt;&lt;/div&gt;&lt;/body&gt; 三、伸缩盒布局 作用：使得子元素在父元素中分列显示，与float的作用类似。一般用于响应式布局（手机app中） 用法 1）父元素在主轴上一定要有一个固定的宽/高 2）子元素在交叉轴上默认宽/高占满父元素 如果主轴为x轴，那么资源的默认高度占满父元素 如果主轴为y轴，那么资源的默认宽度占满父元素 3） 123456789101112 &lt;style&gt; ul &#123; display:flex;&#125; &lt;/style&gt; &lt;body&gt;&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; &lt;/body&gt; 说明： ul 伸缩盒 元素 描述 display:flex; 设置父元素为伸缩盒 flex-direction:row / column ; 主轴 (默认情况下为x轴 )；row 【左中右】/column【上中下】；交叉轴 默认情况下为y轴 ；元素沿着伸缩盒的主轴排列的 flex-wrap:wrap / nowrap ; 子元素宽度和大于父元素的时候是否换行； nowrap（默认值，不换行）； wrap（换行） li 伸缩盒的元素 元素 描述 flex-basis 基础值，主轴上元素的基础值(宽/高) flex-gorw 对盈余空间的分配 flex-shrink 对亏损空间的贡献 flex: grow shrink basis; 速写 eg1: 12345678910111213141516171819202122232425262728293031323334353637383940&lt;title&gt;伸缩盒布局&lt;/title&gt; &lt;style&gt; body &#123; margin: 0; &#125; .outer &#123; display: flex; flex-direction: row; flex-wrap: nowrap; background-color: #ededed; &#125; .outer &gt; div &#123; height: 100px; width: 300px; &#125; .outer &gt;div:nth-child(1)&#123; background-color: teal; /*flex-basis: 300px;*/ flex-grow: 1; flex-shrink: 2; &#125; .outer &gt;div:nth-child(2)&#123; background-color: pink; /*flex-basis: 300px;*/ flex-grow: 2; flex-shrink: 1; &#125; .outer &gt;div:nth-child(3)&#123; background-color: lightblue; /*flex-basis: 300px;*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; eg2: 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;title&gt;伸缩盒&lt;/title&gt; &lt;style&gt; body &#123; margin: 0; &#125; .outer &#123; background-color: #ededed; width: 1000px; height: 500px; margin: 0 auto; display: flex; flex-direction: row; flex-wrap: wrap; &#125; .outer &gt; div &#123; &#125; .outer &gt;div:nth-child(1)&#123; background-color: teal; flex-basis: 400px; flex-grow: 1; &#125; .outer &gt;div:nth-child(2)&#123; background-color: pink; flex-basis: 400px; flex-grow: 1; &#125; .outer &gt;div:nth-child(3)&#123; background-color: lightblue; flex-basis: 400px; flex-grow: 1; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;outer&quot;&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;","categories":[],"tags":[]},{"title":"css-动画","slug":"css3-动画","date":"2019-08-11T23:04:08.000Z","updated":"2019-11-06T11:24:08.975Z","comments":true,"path":"2019/08/12/css3-动画/","link":"","permalink":"https://sucj0301.github.io/2019/08/12/css3-动画/","excerpt":"","text":"一、动画定义 @keyframes(关键帧)规则:from和to分别代表动画的开始点和结束点（分别可以用0%和100%来表示) 12345678@keyframes 动画名称 &#123; from&#123; &#125; to&#123; &#125;&#125; 1234567891011@keyframes 动画名称 &#123; 25%&#123; &#125; 50%&#123; &#125; 100%&#123; &#125;&#125; 二、动画应用 1.指定关键帧的名称 animation-name: keyframename/none; 2.动画持续的时间（?s) animation-duration: time; 3.动画延迟时间 animation-delay: time; 4.动画运动方向 animation-direction: normal/reverse/alternate/alternate-reverse/initial/inherit; 值 描述 normal 默认值，动画按正常播放 reverse 动画反向播放 alternate 动画在奇数次（1、3、5…)正向播放，在偶数次（2、4、6…)反向播放 alternate-reverse 动画在奇数次（1、3、5…)反向播放，在偶数次（2、4、6…)正向播放 initial 设置该属性为它的默认值 inherit 从父元素集成该属性 5.动画结束后保留哪个样式 animation-fill-mode: none/forwards/backwards/both ; 值 描述 none 不改变默认值 forwards 保留最后一帧的样式 backwards 保留第一帧的样式 both 动画会在两个方向上扩展动画属性 6.动画播放的次数 animation-iteration-count: n/infinite; 值 描述 n 定义动画播放次数的数值 infinite 规定动画无限次数播放 7.动画执行的时间曲线 animation-timing-function: linear/steps(n)/ease/; linear: 动画从开始到结束的速度是相同的。（匀速） steps(n,start/end): (作用于两个关键帧之间，而非整个动画) 把动画分成n步阶段性展示，n必须为整数。 start和end可选。指定在每个间隔的起点还是终点发生阶跃变化。 start：第一帧是第一步动画结束 end ：第一帧是第一步动画开始 8.动画播放状态 animation-play-state: running/paused; 值 描述 running 动画播放 paused 动画暂停 9.速写 animation: duration timing-function delay iteration-count direction move_eye ; 示例（css3仿梦幻西游动画特效）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;css3模仿梦幻西游手游动画&lt;/title&gt; &lt;style&gt; .content&#123; position: absolute; width: 950px; /* background-color: pink; */ left: 50%; margin-left: -475px; bottom: 300px; &#125; .content &gt; ul&#123; padding: 0; margin: 0; list-style: none; &#125; .content &gt; ul::after&#123; display:block; content: &quot;&quot;; clear: both; &#125; .content &gt; ul &gt;li&#123; width:200px; height: 180px; margin-right: 50px; float: left; /* background-color: teal; */ overflow: hidden; /* 定义溢出元素内容区的内容会如何处理。visible：默认值，内容不会被剪切，会呈现在元素框之外 hidden：内容会被剪切，并且其余内容是不可见的；scrol：内容会被剪切，但是浏览器会显示滚动条以便查看其余内容 ；auto：如果内容会被剪切，则浏览器会显示滚动条以便查看其余的内容；inherit：规定应该从父元素集成overflow属性的值*/ &#125; .content &gt; ul&gt;li:last-child&#123; margin-right: 0; &#125; .content &gt; ul &gt; li&gt;div&#123; width: 1600px; height: 180px; font-size: 0; /*不加的话会有一个回车 */ /* 2.动画的引用 */ animation-name: dong; /*动画名称*/ animation-duration: 1s; /*动画持续时间（单位s一定要加）*/ /* animation-delay: 1s; 动画延迟（s） */ animation-iteration-count: infinite; /*动画执行次数。1）直接加数字表示次数；2）infinite：无限次*/ /* animation-direction: reverse; */ /*动画运动方向。reverse：动画效果从后往前运动，从from到to；alternate：往返运动*/ animation-timing-function:steps(8); /*时间曲线。linear：线性；steps(n):步数。一次跨n步*/ &#125; .content &gt; ul &gt; li&gt;div &gt; img&#123; width: 100%; &#125; /* 1.定义动画 */ @keyframes dong &#123; from &#123; margin-left: 0; &#125; to &#123; margin-left: -1600px; &#125; &#125; /*从一个状态到另一个状态 */ html,body,.main &#123; height:100%; &#125; .main &#123; width: 100%; overflow: hidden; &#125; .main &gt; .bg &#123; position: relative; width: 3920px; height: 100%; background-image: url(&apos;./image/mhxybj.jpg&apos;); background-repeat: repeat-x; animation-name: bg; animation-duration: 30s; animation-timing-function: linear; animation-iteration-count: infinite; &#125; @keyframes bg &#123; from&#123; left:-1920px; &#125; to&#123; left: 0; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;main&quot;&gt;&lt;div class=&quot;bg&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;content&quot;&gt; &lt;ul&gt; &lt;li&gt;&lt;div&gt;&lt;img src=&quot;./image/wk.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;/li&gt; &lt;li&gt;&lt;div&gt;&lt;img src=&quot;./image/bj.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;/li&gt; &lt;li&gt;&lt;div&gt;&lt;img src=&quot;./image/ts.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;/li&gt; &lt;li&gt;&lt;div&gt;&lt;img src=&quot;./image/ss.png&quot; alt=&quot;&quot;&gt;&lt;/div&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[]},{"title":"css3--规则","slug":"css3-规则","date":"2019-08-03T12:13:33.000Z","updated":"2019-11-06T11:14:33.089Z","comments":true,"path":"2019/08/03/css3-规则/","link":"","permalink":"https://sucj0301.github.io/2019/08/03/css3-规则/","excerpt":"","text":"1.字体样式（可以被继承）12345font-family:&quot;微软雅黑&quot;,&quot;Microsoft YaHei&quot;,&quot;宋体&quot;,serif;font-size:12px; 字体大小(浏览器默认字体为16px)font-weight:bold/normal/bolder/100~900; 字体粗细font-style:normal/italic; 是否开启斜体line-height:2em; 行高【文本垂直居中】 速写：font:style weight size/line-height family; 例如：italic bold 12px/2em ‘Microsoft YaHei’,serif 网络字体:主要用于字体图标库（iconfont/fontawesome） 使用步骤： 1) 在iconfont网站中选择图标，加入项目，产生代码 2) 将产生的代码在html中通过link引用 例：&lt;link rel=&quot;stylesheet&quot; href=&quot;http://at.alicdn.com/t/font_1328534_f3dyyeuoew.css&quot;&gt; 3) 应用css中定义好的类，来使用对应的图标 例：&lt;i class=&quot;iconfont icon-xxx&quot;&gt;&lt;/i&gt; 2.文本样式（可以被继承） 样式 描述 color:#333; 字体颜色 text-align:center/left/right; 文本位置(居中/偏左/偏右) text-decoration-line:属性值 文本修饰(详情见下表) text-decoration-style:属性值 规定线条如何显示(详情见下表) text-decoration-color:属性值 文本修饰（underline、overline、line-through）的颜色 text-decoration-line: none|underline|overline|line-through|initial|inherit; 属性值 描述 none 默认值。规定文本修饰没有线条。 underline 规定文本的下方将显示一条线。 overline 规定文本的上方将显示一条线。 line-through 规定文本的中间将显示一条线。 initial 设置该属性为它的默认值。 inherit 从父元素继承该属性。 text-decoration-style: solid|double|dotted|dashed|wavy|initial|inherit; 属性值 描述 solid 默认值。线条将显示为单线。 double 线条将显示为双线。 dotted 线条将显示为点状线。 dashed 线条将显示为虚线。 wavy 线条将显示为波浪线。 initial 设置该属性为它的默认值。 inherit 从父元素继承该属性。 text-decoration-color: color|initial|inherit; 属性值 描述 color 规定文本修饰的颜色。 initial 设置该属性为它的默认值。 inherit 从父元素继承该属性。 3.列表样式 样式 描述 list-style-type:none/disc/circle/square; 列表项标记的类型(无标记/默认，实心圆/空心圆/实心方块) list-style-image:url(“”); 将图像作为列表项标记 list-style-position:inside/outside; 在何处放置列表项标记 list-style:none; 所有的列表样式 4.盒子样式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475widthheightmargin-top 外边距（上）margin-right 外边距（右）margin-bottom 外边距（下）margin-left 外边距（左）margin margin:10px; 上右下左 margin:0 10px; 上下为0，左右10px margin:0 5px 10px; 上0，左右5px，下10px margin:0 5px 10px 15px; 上右下左 border-top-style 边框线类型border-top-width 边框宽度border-top-color 边框线颜色border-topborder-right-style 边框线类型border-right-width 边框宽度border-right-color 边框线颜色border-rightborder-bottom-style 边框线类型border-bottom-width 边框宽度border-bottom-color 边框线颜色border-bottomborder-left-style 边框线类型border-left-width 边框宽度border-left-color 边框线颜色border-leftborder-colorborder-styleborder-widthborder:1px solid #ededed; 【*】padding-toppadding-rightpadding-bottompadding-leftpaddingbox-shadow: 5px 5px 10px #ccc;box-shadow:inset 0 0 3px lightblue;border-radius 圆角半径background-origin 背景铺设的起点 border-box 边框下 padding-box 内边距下 content-box 内容下background-image 背景图片 urlbackground-repeat 背景重复方式 repeat-x repeat-y no-repeatbackground-color 背景颜色 颜色background-position 背景位置 center top left 10px 20pxbackground-clip 背景裁切方式 border-box 边框下 padding-box 内边距下 content-box 内容下background 速写background:url(&apos;&apos;) no-repeat center;background-size:cover;=&gt;background:center/cover padding-box url(&apos;&apos;) no-repeat ; 5、盒子的组成 外边距 margin 边框 border 内边距 padding 内容 content，存放子元素或者内容的区域 6.盒子的计算方式box-sizing:content-box;内容盒子（传统盒子） width = 内容宽 height = 内容高 所占的宽 = border + padding + width 所占的高 = border + padding + height box-sizing:border-box;边框盒子（怪异盒子） width = 边框以内所有的和 width = border + padding + 内容宽 7.单位(1)颜色 单位 描述 (颜色名) #333/red rgb(x,x,x) rgb(0,0,0) =&gt; #000000 rgba(x,x,x,0.x) 渐变，rgba(0,0,0,0.3) (2)尺寸（常用） 单位 描述 px 绝对单位，font-size=12px; em 相对单位，1em=12px; rem 相对单位，1rem = 14px; % 百分比(相对于父元素)","categories":[],"tags":[]},{"title":"css3-选择器","slug":"css3-选择器","date":"2019-07-30T11:05:34.000Z","updated":"2019-11-06T09:02:12.367Z","comments":true,"path":"2019/07/30/css3-选择器/","link":"","permalink":"https://sucj0301.github.io/2019/07/30/css3-选择器/","excerpt":"","text":"如何在html中应用css 1) 在元素中添加style属性，style属性值为css样式规则 缺点:样式与结构与杂糅 优点:简单直接，优先级高&lt;div style=&quot;width:100px;height:100px;&quot;&gt;&lt;/div&gt;2) 将样式添加到head标签中的style标签里&lt;style&gt; &lt;/style&gt;3) 将样式定义在css文件中，通过link导入进来 &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot;&gt; 一、css语法选择器 { 样式名:样式值; 样式名:样式值; … } 二、选择器1.核心选择器 选择器 表达式 举例 描述 标签选择器 el div 选择所有 div 元素 id选择器 #id #first 选择 id=”first” 的所有元素 class选择器 .class .head 选择所有 class=”head” 的元素 属性选择器 - - (另附表) 通配选择器 * * 即普遍选择器，选择所有元素 属性选择器 类型 举例 描述 [attribute] [target] 选择带有 target 属性所有元素 [attribute=value] [target=_blank] 选择 target=”_blank” 的所有元素 [attribute~=value] [title~=flower] 选择 title 属性包含单词 “flower” 的所有元素 [attribute^=”value”] [abc^=”def”] 选择 abc 属性值以 “def” 开头的所有元素 [attribute$=”value”] [abc$=”def”] 选择 abc 属性值以 “def” 结尾的所有元素 [attribute*=”value”] [abc*=”def”] 选择 abc 属性值中包含子串 “def” 的所有元素 2.层次选择器 选择器 表达式 举例 描述 子元素选择器 el &gt; el div&gt;p 选择 div 的第一子代的所有 p 元素 后代选择器 el el div p 选择 div 元素内部的所有 p 元素 相邻兄弟选择器 el + el div+p 选择与 div 同级且紧接在其后的第一个 p 元素 之后所有兄弟选择器 el ~ el div ~ p 选择与 div 同级且在其后的所有 p 元素 并集选择器 el,el div,p 选择所有 div 元素和所有 p 元素 交集选择器 elel p.first 选择 p 标签且class=”first”的元素 (选择器可以是标签名也可以是id或是class名，中间无连接符) 3.伪类选择器 选择器 举例 描述 :link a:link 选择所有未被访问的链接 :visited a:visited 选择所有已被访问的链接 :active a:active 选择正在被点击的活动链接 :hover a:hover 选择鼠标指针位于其上的链接 ：focus input:focus 用于选择具有焦点的元素(接受键盘事件或其他用户输入的元素),这里表示选择获得焦点的 input 元素 :checked input:checked 选择处于选中状态的radio(&lt;input type=&quot;radio&quot;&gt;), checkbox (&lt;input type=&quot;checkbox&quot;&gt;) 或(“select”) 元素中的option HTML元素(“option”) :selected :selected、.table:selected 可以单独使用，表示选取被选择的 option 元素；也可以配合其他选择器使用，这里表示class=”table”下的select的option选项 :first-child p:first-child 选择属于父元素的第一个子元素的每个 p 元素 :last-child p:last-child 选择属于其父元素最后一个子元素每个 p 元素 :nth-child(n) p:nth-child(2) 选择属于其父元素的第二个子元素的每个 p 元素 :first-of-type p:first-of-type 选择属于其父元素的首个 p元素的每个 p 元素 :last-of-type p:last-of-type 选择属于其父元素的最后 p 元素的每个 p 元素 :nth-of-type(n) p:nth-of-type(2) 选择属于其父元素第二个 p 元素的每个 p 元素 4.伪元素选择器 注：伪元素选择器不能匹配任何真实存在的html元素 ::before 创建一个伪元素，其将成为匹配选中的元素的第一个子元素。常通过 content 属性来为一个元素添加修饰性的内容。此元素默认为行内元素。 1234* Add a heart before links */a::before &#123; content: &quot;♥&quot;;&#125; ::after 用来创建一个伪元素，作为已选中元素的最后一个子元素。通常会配合content属性来为该元素添加装饰内容。这个虚拟元素默认是行内元素。 1234/* Add an arrow after links */a::after &#123; content: &quot;→&quot;;&#125; 常见用法：取消浮动(一般加在父元素上) 12345ul::after&#123; display:block; //设置为块元素 content:&quot;&quot;; //将内容设置为空值 clear:both; //清除周边元素&#125; 注：由::before 和::after 生成的伪元素 包含在元素格式框内，因此不能应用在替换元素上，比如 img 或 br 元素。 ::first-letter 选中某 block-level element（块级元素）第一行的第一个字母，并且文字所处的行之前没有其他内容（如图片和内联的表格） 1234/* Selects the first letter of a &lt;p&gt; */p::first-letter &#123; font-size: 130%;&#125; ::first-line 在某 block-level element （块级元素）的第一行应用样式。第一行的长度取决于很多因素，包括元素宽度，文档宽度和文本的文字大小。 注：::first-line 伪元素只能在块容器中,所以,::first-line伪元素只能在一个display值为block, inline-block, table-cell 或者 table-caption中有用.。在其他的类型中，::first-line 是不起作用的. 例： 123//将每个段落中的第一行字母转换成大写p::first-line &#123; text-transform: uppercase &#125; ::selection 应用于文档中被用户高亮的部分（比如使用鼠标或其他选择设备选中的部分） 只有一小部分CSS属性可以用于::selection 选择器：12345678colorbackground-colorcursorcaret-coloroutline and its longhandstext-decoration and its associated propertiestext-emphasis-colortext-shadow 例：1234567891011/* 选中的文本是红色背景，金黄色的字体 */::selection &#123; color: gold; background-color: red;&#125; /*选中的是蓝色背景，白色的字体的段落*/p::selection &#123; color: white; background-color: blue;&#125; 三、选择器优先级 !important &gt; 内联样式(行内样式) &gt; ID选择器 &gt; 类选择器 = 伪类选择器 = 属性选择器&gt; 标签(元素)选择器 = 伪元素选择器 &gt; 通配选择器 &gt; 继承 &gt; 浏览器默认属性 选择器 权重 ！important 1000 ID选择器 100 类选择器、伪类选择器、属性选择器 10 标签(元素)选择器、伪元素选择器 1 通配符选择器 0","categories":[],"tags":[]},{"title":"html5","slug":"html5","date":"2019-07-20T10:47:40.000Z","updated":"2019-11-06T06:55:53.916Z","comments":true,"path":"2019/07/20/html5/","link":"","permalink":"https://sucj0301.github.io/2019/07/20/html5/","excerpt":"","text":"一、网页元素1234&lt;p&gt;内容&lt;/p&gt; 段落标签&lt;a href=&quot;&quot;&gt;这是一个链接&lt;/a&gt; a标签，定义链接&lt;hr&gt; 换行..... 二、属性 在开始标签中可以添加属性 注：属性名不区分大小写 12&lt;div id=&quot;one&quot;&gt;&lt;/div&gt;&lt;div ID=&quot;one&quot;&gt;&lt;/div&gt; 核心属性（绝大多数标签都可以应用的属性 id 文档内部的唯一标识 class 类 123&lt;div class=&quot;first one&quot;&gt;one&lt;/div&gt;&lt;div class=&quot;first two&quot;&gt;two&lt;/div&gt;&lt;div class=&quot;first three&quot;&gt;three&lt;/div&gt; title 描述 style 样式，取值为css规则(键值对，键值之间通过冒号分割，规则之间通过分号分割) 1&lt;div id=&apos;one&apos; style=&quot;color:#333;backgroud:#ededed&quot;&gt;&lt;/div&gt; 特有属性 1- &lt;a href=&quot;链接地址&quot; target=&quot;链接打开的方式 &quot;&gt;点击链接&lt;/a&gt; target属性值 描述 _blank 在浏览器新窗口中打开被链接文档 _self 默认。在相反的框架中翻开被链接文档。阅读器从头载入彀页 _parent 在父框架斥逐打开被链接文档 _top 在整个窗口中掀开被链接文档 1- &lt;img src=&quot;图片的url&quot; alt=&quot;图片出错时显示的文本&quot; title=&quot;鼠标悬停时显示的文本&quot;&gt;&lt;/img&gt; h5拓展属性 (常用) data-xxx 存储页面自定义的数据例： 1&lt;div data-nn=&apos;one&apos;&gt;&lt;/div&gt; 三、结构1234567891011121314151617doctype 声明部分 htmlhead 不会显示到浏览器视口中 title 显示在浏览器选项卡 meta 用于设置元信息,配置 charset=utf-8 gbk big5 报社 环球新闻导报（php） utf-8 nihao 汉语拼音 hello 函数 编码 编辑器 UTF-8 解码 浏览器 body 网页主体 四、标签12345&lt;html&gt; 定义 HTML 文档&lt;body&gt; 定义文档的主体&lt;h1&gt; - &lt;h6&gt; 定义 HTML 标题&lt;hr&gt; 定义水平线&lt;!--...--&gt; 定义注释 五、元素1. 块元素（box） 作用：作为页面框架，或者容器。是页面的主体 特性： 1) 独占一行空间 2) 默认宽度为100%，默认高度由子元素或者内容决定 3) 可以为其指定宽高 style=”width:;height:;” 标签 描述 属性 html 定义HTML文档 margin body 定义文档的主体 margin div 无意义的块元素 h1~h6 定义HTML标题 font-size、font-weight、margin p 段落 margin hr 定义水平线 ul、li 无序列表，列表项 ul：margin、padding、list-style ol、li 有序列表，列表项 ol：margin、padding、list-style dl、dt、dd 有序列表 dl、dd：margin H5新增： 标签 描述 header 头 nav 定义导航链接 article 主体 section 部分 footer 脚 aside 侧边框 使用详情可查看此文章 2. 行内元素（label） 作用：点缀网页，填充内容 特性： 1) 与其他行内元素共享一行空间 2) 默认宽高由内容决定 3) 不能为其指定宽和高 4) 行内元素中不可以嵌套块元素，但块元素中可以嵌套行内元素 标签 描述 span 无意义的行内元素 a 超链接 img 引入图片 strong 语气更强的强调的内容 blod、b 字体加粗 em 定义为强调的内容 i 斜体文本效果 sub 定义下标文本 sup 定义上标文本 del 定义文档中已被删除的文本 … … 更多的可参考此文章 a标签：默认样式:color、text-decoration、cursor 默认事件:点击事件 123456普通的链接：&lt;a href=&quot;http://www.example.com/&quot;&gt;链接文本&lt;/a&gt;图像链接： &lt;a href=&quot;http://www.example.com/&quot;&gt;&lt;img src=&quot;URL&quot; alt=&quot;替换文本&quot;&gt;&lt;/a&gt;邮件链接： &lt;a href=&quot;mailto:webmaster@example.com&quot;&gt;发送e-mail&lt;/a&gt;书签：&lt;a id=&quot;tips&quot;&gt;提示部分&lt;/a&gt;&lt;a href=&quot;#tips&quot;&gt;跳到提示部分&lt;/a&gt; 3. 功能元素 （也是行内元素） 1) 表格 123456789101112131415table 【属性】border、width、、、、 caption 表格标题 thead 表头部分 tr th/td tbody 表格主体部分【不可以省略】 tr td/th 【属性】colspan、rowspan、width、align td/th中可以放任意子元素 tfoot 表底部分 tr td【注意】：每一行中的列数应该是相等 2) 表单（前后台交互） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;form action=&quot;&quot;&gt; input select textarea&lt;/form&gt;form action 后台接口地址 method 请求方式 get 参数拼接在url后面，通过?来分割 传递参数较少 查询学生信息、通过id删除学生信息、 post 参数存放在请求体中，安全 传递参数更多 保存或者更新学生信息、批量删除 enctype 编码方式 1. enctype=&apos;application/x-www-form-urlencoded&apos; 浏览器就会将参数转换为【查询字符串 qs】格式 username=charles&amp;password=123321&amp;nickname=李四&amp;emailcharles@briup.com 2. multipart/form-data 当有附件在表单中的时候，enctype务必设置为这种格式 ajax 查询字符串 username=charles&amp;password=123321&amp;nickname=李四&amp;emailcharles@briup.com JSON &apos;&#123;&quot;username&quot;:&quot;charles&quot;,&quot;password&quot;:&quot;123321&quot;&#125;&apos; &lt;input name=&quot;&quot; value=&quot;&quot; type=&quot;&quot; palceholder=&quot;&quot; checked&gt; name: 不能省略，作为参数中的key value: 作为参数中的value,在按钮中务必指定value值 type: text 单行文本框 password 密码框 submit 提交按钮 reset 重置 hidden 隐藏 file 附件选择器 radio 单选按钮 checkbox 复选按钮h5拓展(兼容性，功能) email date number ... progress checked: 单值属性 默认选址 placeholder 提示语 &lt;select name=&quot;&quot; id=&quot;&quot;&gt; &lt;option value=&quot;&quot;&gt;&lt;/option&gt; option 标签中的文本显示在网页中，提交的值应该是option的value值，当这个值没有设定的时候，提交的是标签中的文本 &lt;option value=&quot;sx&quot;&gt;山西&lt;/option&gt; &lt;option&gt;山西&lt;/option&gt; &lt;/select&gt; &lt;textarea name=&quot;&quot; id=&quot;&quot; cols=&quot;30&quot; rows=&quot;10&quot; placeholder=&quot;提示语&quot;&gt;&lt;/textarea&gt; 多行文本域第三方库 日期插件 地址选择器地址 附件上传 富文本 六、H5新特性 1、用于绘画的 canvas 元素 2、用于媒介回放的 video 和 audio 元素 3、对本地离线存储的更好的支持 4、新的特殊内容元素，比如 article、footer、header、nav、section 5、新的表单控件，比如 calendar、date、time、email、url、search","categories":[],"tags":[]}]}